<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concise Rust &amp; WebAssembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded "><a href="ch01-00-rust-history.html"><strong aria-hidden="true">1.</strong> Concise Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-variables-data-types.html"><strong aria-hidden="true">1.1.</strong> Variables and Data Types</a></li><li class="chapter-item expanded "><a href="ch01-02-functions-block-scope.html"><strong aria-hidden="true">1.2.</strong> Functions, Blocks and Scope</a></li><li class="chapter-item expanded "><a href="ch01-03-ownership-borrowing-slices.html"><strong aria-hidden="true">1.3.</strong> Ownership, Borrowing and Slices</a></li><li class="chapter-item expanded "><a href="ch01-04-structs-enums-implementation.html"><strong aria-hidden="true">1.4.</strong> Struct, Enums and Implementation</a></li><li class="chapter-item expanded "><a href="ch01-05-generics-traits-lifetimes.html"><strong aria-hidden="true">1.5.</strong> Generics, Traits and Lifetimes</a></li><li class="chapter-item expanded "><a href="ch01-06-collections.html"><strong aria-hidden="true">1.6.</strong> Collections</a></li><li class="chapter-item expanded "><a href="ch01-07-closures-iterators.html"><strong aria-hidden="true">1.7.</strong> Closures and Iterators</a></li><li class="chapter-item expanded "><a href="ch01-08-control-flow.html"><strong aria-hidden="true">1.8.</strong> Control Flow</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.9.</strong> Smart Pointers</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.10.</strong> Asynchronous Programming</div></li><li class="chapter-item expanded "><a href="ch01-xx-concurrency.html"><strong aria-hidden="true">1.11.</strong> Concurrency</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.12.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Concise WebAssembly</div></li><li class="chapter-item expanded "><a href="ch03-00-crates-modules.html"><strong aria-hidden="true">3.</strong> Crates and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-xx-useful-crates.html"><strong aria-hidden="true">3.1.</strong> Useful Crates</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-xx-ecosysten-rustup-cargo.html"><strong aria-hidden="true">4.</strong> Rustup and Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Testing</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Documentation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Benchmarking</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concise Rust &amp; WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cedeber/concise-rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Hello. I hope this book finds you well.</p>
<blockquote>
<p>This book is currently beeing written.</p>
</blockquote>
<p>As a non-daily rustacean - I am a daily TypeScript developer and UI designer -, coming back to Rust only from time to time is sometimes painful. I tend to forget how to code with Rust. Although it is a very nice language, it is also a complex and explicit language. There is a lot to keep in mind.</p>
<p>This little book is the book I want to always have with me when I code with Rust. Unfortunately, it will not cover everything about Rust but, for sure, enough to let you code any kind of high-level application. If you want to go unsafe and manage the memory yourself, this book will certainly not cover what you need. To be fair, at this level of understanding of the language, you probably do not need this book anyway. I will assume, though, that you have already coded before, at least with another C-like language. I hope this book will help you as much as I had fun writing it.</p>
<p><em>— <a href="https://www.cedeber.fr">Cédric Eberhardt</a></em>.</p>
<blockquote>
<p>Don't hesitate to <a href="https://github.com/cedeber/concise-rust-book">contribute</a> if you are missing something or if I did a mistake, which is to expect, as I still consider myself as a Rust beginner. Thank you in advance for the help.</p>
</blockquote>
<p>If you want to play a bit with Rust without installing it, there is a <a href="https://play.rust-lang.org">Rust Playground</a> for that.</p>
<h2 id="inspiration-and-references"><a class="header" href="#inspiration-and-references">Inspiration and references</a></h2>
<ul>
<li>
<p><a href="https://doc.rust-lang.org/stable/book/">The official Rust Book</a>, of course, from which I shamelessly copy the important parts to create this best-of concise book. It is very well written and a must-read recommendation if I convince you to learn more about Rust.</p>
</li>
<li>
<p><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a>
from <a href="https://fasterthanli.me">amos</a></p>
</li>
<li>
<p>...</p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/">Rust by example</a></p>
</li>
<li>
<p><a href="https://doc.rust-lang.org/nomicon/">The Rustonomicon</a></p>
</li>
<li>
<p><a href="https://rustwasm.github.io/docs/book/">The Rust and WebAssembly Book</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-rust"><a class="header" href="#concise-rust">Concise Rust</a></h1>
<h2 id="short-history-of-rust"><a class="header" href="#short-history-of-rust">Short history of Rust</a></h2>
<p>Rust began, in 2006, as a side project of Graydon Hoare, an employee at Mozilla. Mozilla believed in the potential of this new language and began sponsoring it. It was revealed to the world in 2010.</p>
<p>According to Hoare, the name of the language comes from the rust fungus. This has caused Rust programmers to adopt “Rustaceans” as their nickname of choice.</p>
<p>In mid-2020, following the layoffs at Mozilla, the Rust core team said they were considering a new Rust foundation to boost Rust independence. It was officially announced in February 2021.</p>
<h3 id="editions"><a class="header" href="#editions">Editions</a></h3>
<ul>
<li>Rust 2015: <code>1.0</code> (cargo’s <code>edition</code> has been introduced in 2017)</li>
<li>Rust 2018: <code>1.31</code> or <code>edition=&quot;2018&quot;</code></li>
<li>Rust 2021: <code>1.56</code> or <code>edition=&quot;2021&quot;</code></li>
</ul>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Rust is a very nice language. It has been designed to cover most development areas, from an easy CLI application to system programming. And all of that with <strong>safety</strong>, <strong>control</strong> and <strong>productivity</strong> in mind.</p>
<p>Regarding safety, you can think of Python, and for control, C. Rust is some kind of mix of the best of both of these worlds. While I do not think Rust is a good replacement for Python as such, it is for sure a perfect replacement for C or any low-level languages, with the safety and fun of Python, but without trading the <strong>performance</strong> of C-like languages at the same time.</p>
<p>A more personal point of view, what I like too, is the fact that Rust is an <strong>explicit</strong> language. There is no magic. What you read if what it is going to happen. There are no tricks, like for instance in JavaScript, where Array and Object are passed by reference. If you don't know that, you will have weird side effects. In Rust you always know what happens, even with mutability. You will definitely code with <strong>confidence</strong>.</p>
<blockquote>
<p>The Rust programming language is fundamentally about empowerment: no matter what kind of code you are writing, Rust empowers you to reach further, to program with confidence in a wide variety of domains than you did before.</p>
<p>— <em>Foreword from the Rust programming language book.</em></p>
</blockquote>
<p>In the other hand, it makes things a little bit more complex and <strong>noisy</strong>.
Well, this is the reason of this book and why Rust is known to have a steep learning curve.</p>
<h3 id="what-makes-it-different-to-most-of-common-programming-languages"><a class="header" href="#what-makes-it-different-to-most-of-common-programming-languages">What makes it different to most of common programming languages?</a></h3>
<ul>
<li>It does <strong>not have a garbage collector</strong>. But you can still choose how the memory is managed. And you do not have to free the memory yourself. It has a lot of smart pointers for <strong>memory efficiency</strong>.</li>
<li>Because of how memory is managed - the <strong>ownership</strong> principle - it is <strong>memory and thread safe</strong>. There are no dangling pointers, no data race, no buffer overflow, no iterator invalidation.</li>
<li>It keeps <strong>performance</strong>, very close to what C can offer. Even sometimes faster.</li>
<li>No <code>null</code> pointer exceptions.</li>
<li>No <code>class</code> and so, no <code>inheritance</code>.</li>
<li>First-class <strong>WebAssembly</strong> support.</li>
</ul>
<h3 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h3>
<p>Last but not least, although not related to the Rust language itself, the whole ecosystem and tooling around Rust is just awesome. It is definitely feature-complete:</p>
<ul>
<li>A complete ecosystem (<code>rustup</code>, <code>cargo</code>, <code>crates</code>, <code>rustfmt</code>, <code>clippy</code>, ...)</li>
<li>Good IDE support (IntelliJ-based and VSCode)</li>
<li>Documentation directly in source code, from the comments</li>
<li>Examples folder managed with <code>cargo</code></li>
<li>Tests in source code and <code>cargo test</code></li>
<li><code>cargo</code> can be expanded: <code>cargo-edit</code>, <code>cargo-watch</code>, ...</li>
<li>Compiler giving hints thanks to <code>clippy</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-data-types"><a class="header" href="#variables-and-data-types">Variables and Data types</a></h1>
<h2 id="variable-binding-and-type-inference"><a class="header" href="#variable-binding-and-type-inference">Variable binding and Type inference</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = bar;
<span class="boring">}
</span></code></pre></pre>
<p>This line creates a new variable named <code>foo</code> and binds it to the value of the <code>bar</code> variable.</p>
<p>You don't need to define the type on assignment. But you must bind a value before usage. The compiler can usually infer what type we want to use based on the value and how we use it.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str; // declare str
str = &quot;Hello, world!&quot;; // assignement -&gt; &amp;str

let a = 40_000; // -&gt; i32
let b = 40.; // -&gt; f64
let v: [_; 5] = [3; 5];
//      ^ infers type for usage

let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The binding can be done at a later stage.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a;
// ... some code
a = 42;
<span class="boring">}
</span></code></pre></pre>
<p>Of course, you can still specify the type manually.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 45;
<span class="boring">}
</span></code></pre></pre>
<h3 id="unused-variables"><a class="header" href="#unused-variables">Unused variables</a></h3>
<p>While you are coding, you can say the compiler to not complain about a variable not being used.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _unused_variable = 42;
<span class="boring">}
</span></code></pre></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<p>The types covered here are all stored on the stack. We will talk about the stack and the heap on another chapter.
What you need to know for now is that the stack is the fast memory.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types: <strong>integers</strong>, <strong>floating point numbers</strong>
, <strong>booleans</strong> and <strong>characters</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: isize = 98_222;
let byt = b'A' // u8 only
let x = 2.0 // f64

let t: bool = true
<span class="boring">}
</span></code></pre></pre>
<p>When you are compiling in release mode, Rust does not checks for integers overflow. If you want to wrap explicitly, you can use the standard library type <code>Wrapping</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zero = 0u8;

println!(&quot;{}&quot;, zero - 1_u8);
//             ^^^^^^^^^^^ attempt to compute `0_u8 - 1_u8`, which would overflow
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::Wrapping;
</span>let zero = Wrapping(0u8);
let one = Wrapping(1u8);

println!(&quot;{}&quot;, (zero - one).0); // -&gt; 255
<span class="boring">}
</span></code></pre></pre>
<p>Rust’s char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more than just ASCII. Accented letters; Chinese, Japanese and Korean characters; emoji; and zero-width spaces are all valid char values in Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heart_eyed_cat = '😻';
<span class="boring">}
</span></code></pre></pre>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p>Rust has two primitive compound types: <strong>tuples</strong> and <strong>arrays</strong>.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>This is a fixed length collections of values of different types.
We can access a tuple element directly bu using a <code>.</code> followed by the index of the value we want to access. The first index in a tuple is <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tupl = ('x', 32); // =&gt; (char, i32)
let x = tupl.0; // =&gt; 'x'
let thirty_two = tupl.1; // =&gt; 32
<span class="boring">}
</span></code></pre></pre>
<p>As we will see in the &quot;pattern&quot; chapter, you can use <em>pattern matching</em> to desctructure a tuple value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (500, 6.4, 1);
let (x, y, z) = tup;
<span class="boring">}
</span></code></pre></pre>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Arrays in Rust have a fixed length, like tuples. Arrays are useful when you want your data allocated on the stack rather than the heap.
You can access elements of an array using indexing. As for tuple, the first index is <code>0</code>. If the index is greater than or equal to the length, Rust will panic because of Rust's safety principle.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];

let first = a[0];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>An array is not as flexible as the vector type. A vector (<code>Vec</code>) is a similar collection type provided by the standard library that is allowed to grow or shrink in size.</p>
</blockquote>
<h2 id="immutable-by-default"><a class="header" href="#immutable-by-default">Immutable by default</a></h2>
<p>Mutability in Rust is explicit. When a variable le is immutable, once a value is bound to a name, you can’t change the value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number { value: i32 }

let foo = 32;
foo = 40; // Nope

let n = Number {
    value: 3
};
n.value = 5; // Nope
n = Number { value: 5 } // Nope
<span class="boring">}
</span></code></pre></pre>
<p>Let's make it <strong>mutable</strong>. The entire instance must be mutable; Rust does not allow us to mark only certain fields as mutable.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number { value: i32 }

let mut foo = 32;
foo = 40; // Yep

let mut n = Number {
    value: 3
};
n.value = 5; // Yep
n = Number { value: 5 } // Yep
<span class="boring">}
</span></code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Constants are like immutable variables, but there are some differences:</p>
<ul>
<li>Declared using the const keyword.</li>
<li>The type must be annotated. You can not infer it.</li>
<li>You are not allowed to use mut with constants.</li>
<li>Set only to a constant expression, not to the result of a function call or any other value that could only be computed at runtime.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Shadowing is different from marking a variable as <code>mut</code>, because we will get a compile-time error if we accidentally try to reassign to this variable without using the <code>let</code> keyword. By using let, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 32;
let x = 32 + 8; // still immutable!

println!(&quot;{}&quot;, x); // =&gt; 40. Only the last x will be available
<span class="boring">}
</span></code></pre></pre>
<p>Even with a different type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 32;
let x = &quot;Hey&quot;;

println!(&quot;{x}&quot;); // =&gt; &quot;Hey&quot;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-blocks-and-scope"><a class="header" href="#functions-blocks-and-scope">Functions, Blocks and Scope</a></h1>
<p>A pair of brackets declares a block, which has its own scope. It can evaluate to a value and can contain multiple statements.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let x = &quot;out&quot;;
	{
		// this is a different `x`
		let x = &quot;in&quot;;
		println!(&quot;{x}&quot;); // =&gt; in
	}
	println!(&quot;{x}&quot;); // =&gt; out
}
</code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions are pervasive in Rust code. The <code>main</code> function is the most important function in the language. It's the entry point of many programs.</p>
<p>The <code>fn</code> keyword allows you to declare new functions. Rust code uses <em>snake case</em> as the conventional style for functions and variables names. Every function returns by default a <strong>unit</strong> type, written <code>()</code>. It's an empty tuple. No need to specify it or return it, it is implicit.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	// empty
}
</code></pre></pre>
<blockquote>
<p>Rust does not care where you define your functions, only that they are defined somewhere.</p>
</blockquote>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>In function signatures, you <em>must</em> declare the type of each parameter.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn another_function(x: i32, y: i32) {
	println!(&quot;x: {}&quot;, x);
	println!(&quot;y: {}&quot;, y);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="return-value"><a class="header" href="#return-value">Return value</a></h3>
<p>We do declare their type after an arrow <code>-&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
	return x + y;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="statements-and-expressions-in-function-bodies"><a class="header" href="#statements-and-expressions-in-function-bodies">Statements and Expressions in Function Bodies</a></h3>
<p>Rust is an expression-based language. <em>Statements</em> are instructions that perform some action and do not return a value. For instance, the <code>let y = 6</code> statement does not return a value. <em>Expressions</em> evaluate to a resulting value. Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, <code>{}</code>, is an expression.</p>
<blockquote>
<p>Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_2(a: i32) -&gt; i32 {
	a + 2
}

println!(&quot;{}&quot;, add_2(5)); // =&gt; 7
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-borrowing-and-slices"><a class="header" href="#ownership-borrowing-and-slices">Ownership, Borrowing and Slices</a></h1>
<p>Ownership is the most unique feature of Rust, and it enables Rust to make memory safety guarantees without needing a garbage collector.</p>
<blockquote>
<p>Don’t try to fight against the borrow checker.</p>
</blockquote>
<h2 id="the-stack-and-the-heap"><a class="header" href="#the-stack-and-the-heap">The Stack and the Heap</a></h2>
<p>The <em>stack</em> stores values in the order it gets them and removes the values in the opposite order. This is referred to as <em>last in, first out</em>. All data stored in the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>The <em>heap</em> is less organised. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called <em>allocating on the heap</em>.</p>
<p>Pushing to the stack is faster than allocating on the heap because the operating system never has to search for a place to store new data. Comparatively, allocating space on the heap requires more work, because the operating system must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.</p>
<p>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory.</p>
<h2 id="memory-and-allocation"><a class="header" href="#memory-and-allocation">Memory and Allocation</a></h2>
<p>As an example, there are two types of strings in Rust: <code>String</code> and <code>&amp;str</code>.</p>
<ul>
<li>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to always be a valid UTF-8 sequence. String is heap allocated, growable and not null terminated. With the <code>String</code> type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the content.</li>
<li><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and can be used to view into a <code>String</code>, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>. In the case of a string literal, we know the content at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::From(&quot;hello&quot;);

s.push_str(&quot;, world!&quot;); // appends a literal to a String
<span class="boring">}
</span></code></pre></pre>
<h3 id="drop"><a class="header" href="#drop">Drop</a></h3>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <code>drop</code>. Rust call <code>drop</code> automatically at the closing curly bracket.</p>
<h3 id="move"><a class="header" href="#move">Move</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>bind the value 5 to <code>x</code>; then make a <strong>copy</strong> of the value in <code>x</code> and bind it to <code>y</code>.</p>
</blockquote>
<p>This is indeed what is happening, because integers are simple values with a known, fixed size and these two 5 values are pushed on the <strong>stack</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>A <code>String</code> is made of three parts: a <em>pointer</em> to the memory that holds the content of the string, a <em>length</em>, and a <em>capacity</em>.</p>
<div style="display: flex; gap: 40px; justify-content: center;">
<div>
<p style="text-align: center;">s1 data</p>
<table><thead><tr><th>name</th><th>value</th></tr></thead><tbody>
<tr><td>ptr</td><td>→</td></tr>
<tr><td>len</td><td>5</td></tr>
<tr><td>capacity</td><td>5</td></tr>
</tbody></table>
</div>
<div>
<p style="text-align: center;">content</p>
<table><thead><tr><th>index</th><th>value</th></tr></thead><tbody>
<tr><td>0</td><td>h</td></tr>
<tr><td>1</td><td>e</td></tr>
<tr><td>2</td><td>l</td></tr>
<tr><td>3</td><td>l</td></tr>
<tr><td>4</td><td>o</td></tr>
</tbody></table>
</div>
</div>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the pointer, the length, and the capacity that are on the <strong>stack</strong>.
<em>We do not copy the data on the heap that the pointer refers to</em>.</p>
<p>Again, when a variable goes out of scope, Rust automatically calls the <code>drop</code> function and cleans up the heap memory for that variable.
When s2 and s1 go out of scope, they will both try to free the same memory. This is known as a <em>double free</em> error and is one of the memory safety bugs.</p>
<p>Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and, therefore, Rust doesn't need to free anything when s1 goes out of scope.</p>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of calling it a shallow copy, it’s known as a <em>move</em>.</p>
<blockquote>
<p>Rust will never automatically create “deep” copies of your data. Therefore, any <em>automatic</em> copying can be assumed to be inexpensive in terms of runtime performance.</p>
</blockquote>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.</p>
<h3 id="stack-only-data-copy"><a class="header" href="#stack-only-data-copy">Stack-Only Data: Copy</a></h3>
<p>Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make.
In other words, there’s no difference between deep and shallow copying here, so calling clone wouldn’t do anything different from the usual shallow copying and we can leave it out.</p>
<blockquote>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on types that are stored on the stack like integers are.</p>
</blockquote>
<p>Here are some of the types that implement Copy:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>.</li>
</ul>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<p>Passing a variable to a function will <code>move</code> or <code>copy</code>, just as assignment does.
The ownership of a variable follows the same pattern every time: assigning a value to another variable <strong>moves</strong> it.</p>
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let s1 = String::from(&quot;hello&quot;);
	let len = calculate_length(&amp;s1);
	println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
	s.len()
}
</code></pre></pre>
<p>These ampersands are <em>references</em>, and they allow you to refer to some value without taking ownership of it.</p>
<blockquote>
<p>The opposite of referencing by using <code>&amp;</code> is <em>deferencing</em>, which is accomplished with the dereference operator <code>*</code>.</p>
</blockquote>
<p>Just as variables are immutable by default, so are references. But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;mut s;
//       ------ first mutable borrow occurs here
let r2 = &amp;mut s;
//       ^^^^^^ second mutable borrow occurs here

println!(&quot;{}, {}&quot;, r1, r2);
//                 -- first borrow later used here
<span class="boring">}
</span></code></pre></pre>
<p>The benefit of having this restriction is that Rust can prevent data races at compile time. As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <em>simultaneous</em> ones.</p>
<p>A similar rule exists for combining mutable and immutable references. We also cannot have a mutable reference while we have an immutable one.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;s;
//       -- immutable borrow occurs here
let r2 = &amp;s;
let r3 = &amp;mut s;
//       ^^^^^^ mutable borrow occurs here

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
//                         -- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<h3 id="dangling-references"><a class="header" href="#dangling-references">Dangling references</a></h3>
<p>In language with pointers, it's easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that have been given to someone else or freed. In Rust, if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let ref_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
//             ^ expected named lifetime parameter

	let s = String::from(&quot;hello&quot;);

	&amp;s
}
</code></pre></pre>
<p>Because <code>s</code> is created inside <code>dangle</code>, when the code of <code>dangle</code> is finished, <code>s</code> will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid <code>String</code>.</p>
<h3 id="the-slice-type"><a class="header" href="#the-slice-type">The Slice Type</a></h3>
<p>Another data type that does not have ownership is the <em>slice</em>. Slices let you reference a continuous sequence of elements in a collection rather than the whole collection.</p>
<p>A <em>string slice</em>, for instance, is a reference to part of a <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>With Rust's <code>..</code> range syntax,</p>
<ul>
<li>if you want to start at the first index (zero), you can drop the trailing number: <code>[..5]</code></li>
<li>if your slice includes the last byte of the <code>String</code>, you can drop the trailing number: <code>[6..]</code></li>
<li>you can also drop both values to take a slice of the entire <code>String</code>: <code>[..]</code></li>
</ul>
<p>Recall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference. In the example bellow, because <code>clear</code> needs to truncate the <code>String</code>, it tries to take a mutable reference, which fails.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let word = first_word(&amp;s)
//                    -- immutable borrow occurs here
s.clear();
//^^^^^^^ mutable borrow occurs here
println!(&quot;the first word is: {}&quot;, word);
//                                ---- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<h4 id="other-slices"><a class="header" href="#other-slices">Other Slices</a></h4>
<ul>
<li>String literals are slices</li>
<li>Arrays are a general slice type, like <code>&amp;[i32]</code></li>
</ul>
<h2 id="recap"><a class="header" href="#recap">Recap</a></h2>
<h3 id="the-rules-of-ownership"><a class="header" href="#the-rules-of-ownership">The Rules of Ownership</a></h3>
<ul>
<li>Each value in Rust has a variable that's called its <em>owner</em>.</li>
<li>There can be only one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p>The next example will fail as name has been passed to <code>Person.first_name</code>, bound to <code>p</code> and is not owned by <code>name</code> anymore.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	first_name: String,
}

fn main() {
	let name = String::from(&quot;Cédric&quot;);
	//  ---- move occurs because `name` has type `String`,
	//       which does not implement the `Copy` trait

	let p = Person { first_name: name };
	//                            ---- value moved here

	println!(&quot;{}&quot;, name);
	//             ^^^^ value borrowed here after move
}
</code></pre></pre>
<p>It can be borrowed, though. For that you need to use references and lifetime tags.</p>
<h3 id="the-rules-of-references"><a class="header" href="#the-rules-of-references">The Rules of References</a></h3>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<p>The <code>&amp;</code> indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. References are a complex feature, one of Rust’s major advantages is how safe and easy it is to use references. References passed to Person&lt;'a&gt; will now be alive as long as its usage, which is the implicit lifetime of main().</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person&lt;'a&gt; {
	first_name: &amp;'a str,
}

fn main() {
	let name = String::from(&quot;Cédric&quot;);
	let _p = Person { first_name: &amp;name };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<p>Or simply copy or clone the value. Copy is a shallow copy, while Clone is a deep clone.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	name: String,
}

fn main() {
	let name = format!(&quot;Hello, {}!&quot;, &quot;World&quot;);
	let _p = Person { name: name.clone() };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-enums-and-implementation"><a class="header" href="#structs-enums-and-implementation">Structs, Enums and Implementation</a></h1>
<p>There is no <code>class</code> and no inheritance. Rust has only <code>struct</code>, <code>impl</code> and <code>trait</code>.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>A <code>struct</code> is like an object's data attribute.</p>
<blockquote>
<p>It's possible for structs to store references to data owned by something else, but to do so requires the use of <em>lifetimes</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
	width: u32,
	height: u32,
}

let rect = Rectangle { width: 3, height: 2 };
rect.width; // =&gt; 3
<span class="boring">}
</span></code></pre></pre>
<h3 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h3>
<p>Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
let black = Color(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<h3 id="unit-like-structs"><a class="header" href="#unit-like-structs">Unit-Like Structs</a></h3>
<p>You can also define structs that don't have any fields! These are called <em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type. Unit-like structs can be useful in situations in which you need to implement a trait on some type but don't have any data that you want to store in the type itself.</p>
<h2 id="method-syntax-implementation"><a class="header" href="#method-syntax-implementation">Method Syntax: Implementation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn area(&amp;self) -&gt; u32 {
		self.width * self.height
	}
}

let rect = Rectangle { width: 30, height: 50 };
println!(&quot;The are is {} square pixels.&quot;, rect.area());
<span class="boring">}
</span></code></pre></pre>
<p>Methods are similar to functions. To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> block. Then we move the <code>area</code> function within the <code>impl</code> curly brackets.</p>
<p>We can use the <em>method syntax</em> to call the area method on our <code>Rectangle</code> instance.</p>
<p>In the signature for <code>area</code> we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code> because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method's being inside the <code>impl Rectangle</code> context. Methods can take multiple parameters that we add to the signature after the <code>self</code> parameter, and those parameters work just like parameters in functions.</p>
<blockquote>
<p>Each struct is allowed to have multiple <code>impl</code> blocks.</p>
</blockquote>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h3>
<p>Another useful feature of <code>impl</code> blocks is that we are allowed to define functions within <code>impl</code> blocks that <em>do not</em> take <code>self</code> as a parameter. These are called <em>associated functions</em> because they are associated with the struct. They are called after the <code>::</code> syntax.</p>
<blockquote>
<p>They're still functions, not methods, because they don't have an instance of the struct to work with, like <code>String::from</code>. An associated function is implemented on a type, rather than on a particular instance of a <code>Rectangle</code>. Some language call this a <em>static method</em>.</p>
</blockquote>
<p>Associated functions are often used for constructors that will return a new instance of the struct. A common usage in the standard library and in the community is to define a <code>new</code> function. You can use the <em>field init shorthand</em> syntax to initialize a struct with variables.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
	fn new(width: u32, height: u32) -&gt; Self {
		Rectangle { width, height };
	}
}

let rect = Rectangle::new(30, 20);
<span class="boring">}
</span></code></pre></pre>
<h3 id="rest-and-destructuring"><a class="header" href="#rest-and-destructuring">Rest and Destructuring</a></h3>
<p>The rest operator <code>..</code> allows to fill the <em>holes</em>. It is called the <em>struct update syntax</em>.</p>
<blockquote>
<p>The rest must be the last and not be followed by a comma.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Vec2 {
	x: f32,
	y: f32
}

// Rest
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, ..v1 };

// Destructuring a tuple
let (a, b) = (3, 7);

// Destructuring with Rest
let Vec2 { x,..} = v2;

println!(&quot;{:?}, {:?}, {:?}&quot;, v2, b, x) // =&gt; Vec2 { x: 1.0, y: 2.0 }, 7, 1.0
<span class="boring">}
</span></code></pre></pre>
<h4 id="throw-away-a-value"><a class="header" href="#throw-away-a-value">Throw away a value</a></h4>
<p>During destructuring, if you don't want to deal with all values you can omit some with an underscore.
In use with the rest operator <code>..</code> it's very easy to just export what you need.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = get_stuff(); // throws away the returned value

// The value 3 and the rest will not be assigned to a variable
let (_, b, ..) = (3, 7, 14, 45);
let (width, _) = get_size();
<span class="boring">}
</span></code></pre></pre>
<h4 id="function-parameters"><a class="header" href="#function-parameters">Function parameters</a></h4>
<p>Function parameters can also be pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn print_coordinates(&amp;(x, y): &amp;(i32, i32)) {
    println!(&quot;Current location: ({}, {})&quot;, x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&amp;point);
}
</code></pre></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Rust's enums are most similar to <em>algebraic data types</em> in functional languages.
Note that the variants of the enum are namespaced (<code>::</code>) under its identifier.</p>
<p>We can put data directly into each enum variant. You can put any kind of data inside an enum variant: strings, numeric types, or struct, for example. You can even include another enum.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
	V4(u8, u8, u8, u8),
	V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<h3 id="the-billion-dollars-mistake"><a class="header" href="#the-billion-dollars-mistake">The Billion Dollars Mistake</a></h3>
<p>The problem with <code>null</code> values is that if you try to use a <code>null</code> value as a not-null value, you will get an error of some kind.
As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</p>
<p>It is replaced by the <code>Option&lt;T&gt;</code> enumeration. The variants of <code>Option</code> are <code>Some</code>
and <code>None</code>. The <code>None</code> variant represents no value while <code>Some</code> can hold one piece of data of any type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
	Some(T),
	None,
}
<span class="boring">}
</span></code></pre></pre>
<p>If we use <code>None</code> rather that <code>Some</code>, we need to tell Rust what type of <code>Option&lt;T&gt;</code> we have.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val1: Option&lt;i32&gt; = None;
let val2: Option&lt;_&gt; = Some(32);

println!(&quot;{:?}, {:?}&quot;, val1, val2);
<span class="boring">}
</span></code></pre></pre>
<p>Because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won't let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
//          ^ no implementation for `i8 + Option&lt;i8&gt;`
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Everywhere that a value has a type that is not an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value is not null.</p>
</blockquote>
<h3 id="error-management"><a class="header" href="#error-management">Error management</a></h3>
<p>Rust doesn't have exceptions. Instead, it has the type the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</p>
<p><code>Result</code> is, like <code>Option</code>, also an enumeration. For <code>Result&lt;T, E&gt;</code>, the variants are <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code>. The <code>Ok</code> variant indicates the operation was successful, and inside <code>Ok</code> is the successfully generated value.
The <code>Err</code> variant means the operation failed, and <code>Err</code> contains information about how or why the operation failed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

let f = File::open(&quot;hello.txt&quot;);
let f = match f {
	Ok(file) =&gt; file,
	Err(error) =&gt; {
		panic!(&quot;Problem opening the file: {:?}&quot;, error)
	}
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="shortcuts-for-panic-on-error-unwrap-and-expect"><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for Panic on Error: unwrap and expect</a></h4>
<p>Using <code>match</code> can be a bit verbose. The <code>Result&lt;T, E&gt;</code> type has many helper methods.</p>
<p>One of those method is called <code>unwrap</code>. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will call the <code>panic!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;hello.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Another method, <code>expect</code>, which is similar to <code>unwrap</code>, lets us also choose the <code>panic!</code> error message.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>It would be appropriate to call <code>unwrap</code> when you have some other logic that ensures the <code>Result</code> will have an <code>Ok</code> value, but the logic isn't something the compiler understands.</p>
</blockquote>
<h4 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating Errors</a></h4>
<p>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator <code>?</code> to make this easier. Error values that have the <code>?</code> operator called on them go through the <code>from</code> function, defined in the <code>From</code> trait in the standard library, which is used to convert errors from one type into another.</p>
<p>The <code>?</code> operator eliminates a lot of boilerplate and makes this function's implementation simpler. We could even shorten the code further by chaining method calls immediately after the <code>?</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_username_from_file() -&gt; Result&lt;String, io::error&gt; {
	let mut s = String::new();

	File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

	Ok(s);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The <code>?</code> operator can only be used in functions that have a return type of <code>Result</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
	let f = File::open(&quot;hello.txt&quot;)?;

	Ok(());
}
</code></pre></pre>
<p>The <code>Box&lt;dyn Error&gt;</code> type is called a trait object. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean &quot;any kind of error&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-traits-and-lifetimes"><a class="header" href="#generic-types-traits-and-lifetimes">Generic Types, Traits and Lifetimes</a></h1>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics are abstract stand-ins for concrete types or other properties.</p>
<p>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types.</p>
<p>To define the generic <code>largest</code> function, place type name declaration inside angle brackets, <code>&lt;&gt;</code>, between the name of the function and the parameter list.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {}
<span class="boring">}
</span></code></pre></pre>
<p>We can also define structs to use a generic type parameter in one or more fields using the <code>&lt;&gt;</code> syntax.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
	x: T,
	y: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have different types, we can use multiple generic type parameters.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T, U&gt; {
	x: T,
	y: U,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read.</p>
</blockquote>
<p>We can define enums to hold generic data types in their variants as we just see in <code>Option&lt;T&gt;</code> that returns <code>Some&lt;T&gt;</code> for instance.</p>
<p>We can also implement methods on structs and enums and use generic types in their definitions, too.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
	x: T,
	y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
	fn x(&amp;self) -&gt; &amp;T {
		&amp;self.x
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use it to specify that we are implementing methods on the type <code>Point&lt;T&gt;</code>. By declaring <code>T</code> as a generic type after <code>impl</code>, Rust can identify that the type in the angle brackets in <code>Point</code> is a generic type rather than a concrete type.</p>
<p>We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances rather than on <code>Point&lt;T&gt;</code> instances with a generic type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point&lt;f32&gt; {
	fn distance_form_origin(&amp;self) -&gt; f32 {
		(self.x.powi(2) + self.y.powi(2)).sqrt()
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Generic type parameters in a struct definition aren't always the same as those you use in that struct`s method signatures.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T, U&gt; {
	x: T,
	y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
	fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
		Point {
			x: self.x
			y: other.y
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust implements generics by performing monomorphization of the code that is using generics at compile time. <em>Monomorphization</em> is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. With that, there is no runtime cost.</p>
</blockquote>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Trait definitions are a way to group method signatures together to define a set of behaviours necessary to accomplish some purpose. They are some kind of <em>interfaces</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Geometry {
	fn area(&amp;self) -&gt; u32;
}

struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	// Common Rust way to do a &quot;constructor&quot;
	fn new(width: u32, height: u32) -&gt; Self {
		Self { width, height }
	}
}

impl Geometry for Rectangle {
	fn area(&amp;self) -&gt; u32 {
		self.width * self.height
	}
}

fn main() {
	let rect = Rectangle::new(20, 30);

	println!(
		&quot;The area of the rectangle is {} square pixels.&quot;,
		rect.area()
	);
}
</code></pre></pre>
<p>The difference is that after <code>impl</code>, we put the trait name that we want to implement, then use the <code>for</code> keyword, and then specify the name of the type we want to implement the trait for. Within the <code>impl</code> block, we put the method signatures that the trait definition has defined.</p>
<p>One restriction to note with trait implementations is that we can implement a trait on a type only if at least one of the trait or the type is local to our crate. But we can’t implement external traits on external types. This restriction is part of a property of programs called <em>coherence</em>, and more specifically the <em>orphan rule</em>, so named because the parent type is not present. This rule ensures that other people’s code can’t break your code and vice versa. Without the rule, two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
<h3 id="default-implementations"><a class="header" href="#default-implementations">Default Implementations</a></h3>
<p>Sometimes it’s useful to have default behavior for some or all of the methods in a trait instead of requiring implementations for all methods on every type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Read more...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>To use a default implementation we specify an empty <code>impl</code> block. Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</p>
</blockquote>
<h3 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters</a></h3>
<p>We can define a function that calls the method on its parameter, which is of some type that implements the trait. To do this we can use the <code>impl Trait</code> syntax.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>The <code>impl Trait</code> syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a <em>trait bound</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>We can also specify more than one trait bound.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn notify(item: &amp;(impl Summary + Display)) {}
pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {}
<span class="boring">}
</span></code></pre></pre>
<p>Rust has alternate syntax for specifying trait bounds inside a <code>where</code> clause after the function signature.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{}
<span class="boring">}
</span></code></pre></pre>
<h3 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></h3>
<p>We can also use the 'impl Trait' syntax in the return position to return a value of some type that implements a trait.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable() -&gt; impl Summary {
	Tweet {
		// --snip--
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators. However you can only use the <code>impl Trait</code> if you are returning a single type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
	if switch {
		NewsArticle {
			// --snip--
		}
	} else {
		Tweet {
			// --snip--
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Returning either a NewsArticle or a Tweet isn't allowed due to restrictions around how the <code>impl Trait</code> is implemented in the compiler.</p>
</blockquote>
<h3 id="derivable-traits"><a class="header" href="#derivable-traits">Derivable Traits</a></h3>
<blockquote>
<p>TODO: Do the macro chapter first</p>
</blockquote>
<h3 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods</a></h3>
<p>By using a trait bound with an <code>impl</code> block that uses generic type parameters, we can implement methods conditionnally for types that implement the specified traits.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Pair&lt;T&gt; {
	x: T,
	y: T,
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
	// --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>We can also conditionally implement a trait for any type that implements another trait. Implementations of a trait on any type that satisfies the trait bounds are called <em>blanket implementations</em> and are extensively used in the Rust standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;T: Display&gt; ToString for T {
    // --snip--
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>In dynamically typed languages, we would get an error at runtime if we called a method on a type which didn’t define the method. But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run. Additionally, we don’t have to write code that checks for behavior at runtime because we’ve already checked at compile time.</p>
</blockquote>
<h2 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h2>
<p>Most of the time, lifetimes are implicit and inferred, just like most of the time, types are inferred. We must annotate types when multiple types are possible. In a similar way, we must annotate lifetimes when the lifetimes of references could be related in a few different ways</p>
<p>The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it is intended to reference.</p>
<h3 id="the-borrow-checker"><a class="header" href="#the-borrow-checker">The Borrow Checker</a></h3>
<p>The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let r;                // ---------+-- 'a
						  //          |
	{                     //          |
		let x = 5;        // -+-- 'b  |
		r = &amp;x;           //  |       |
	}                     // -+       |
						  //          |
	println!(&quot;r: {}&quot;, r); //          |
}                         // ---------+
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
//            ----     ----     ^ expected named lifetime parameter
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}

//   = help: this function's return type contains a borrowed value,
//           but the signature does not say whether it is borrowed from `x` or `y`
// help: consider introducing a named lifetime parameter
//   |
//   | fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
//   |           ++++     ++          ++          ++
<span class="boring">}
</span></code></pre></pre>
<h3 id="lifetime-annotation"><a class="header" href="#lifetime-annotation">Lifetime annotation</a></h3>
<p>Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase and very short, like generic types. Most people use the name <code>'a</code>. We place lifetime parameter annotations after the <code>&amp;</code> of a reference, using a space to separate the annotation from the reference’s type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>&amp;i32        // a reference
&amp;'a i32     // a reference with an explicit lifetime
&amp;'a mut i32 // a mutable reference with an explicit lifetime
<span class="boring">}
</span></code></pre></pre>
<p>As with generic type parameters, we need to declare generic lifetime parameters inside angle brackets between the function name and the parameter list. The constraint we want to express in this signature is that the lifetimes of both of the parameters and the lifetime of the returned reference are related such that the returned reference will be valid as long as both the parameters are.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
	// --snip--
}
<span class="boring">}
</span></code></pre></pre>
<p>Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints.
In other words, the generic lifetime <code>'a</code> will get the concrete lifetime that is equal to the smaller of the lifetimes of <code>x</code> and <code>y</code>.</p>
<blockquote>
<p>The way in which you need to specify lifetime parameters depends on what your function is doing.</p>
</blockquote>
<p>So far, we’ve only defined structs to hold owned types. It’s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.
We declare the name of the generic lifetime parameter inside angle brackets after the name of the struct so we can use the lifetime parameter in the body of the struct definition.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime elision</a></h3>
<p>You have learned that every reference has a lifetime and that you need to specify lifetime parameters for functions or structs that use references. The Rust team found that Rust programmers were entering the same lifetime annotations over and over in particular situations. These situations were predictable and followed a few deterministic patterns. The developers programmed these patterns into the compiler’s code so the borrow checker could infer the lifetimes in these situations and wouldn’t need explicit annotations.</p>
<blockquote>
<p>The patterns programmed into Rust’s analysis of references are called the <em>lifetime elision rules</em>. Lifetimes on function or method parameters are called <em>input lifetimes</em>, and lifetimes on return values are called <em>output lifetimes</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>The lifetime parameter declaration after impl and its use after the type name are required, but we’re not required to annotate the lifetime of the reference to self because of the first elision rule.</p>
<p>Check <a href="https://doc.rust-lang.org/nomicon/lifetime-elision.html">the Rustonomicon</a></p>
<h3 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The Static Lifetime</a></h3>
<p>One special lifetime we need to discuss is <code>'static</code>, which means that this reference can live for the entire duration of the program. All string literals have the <code>'static</code> lifetime.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;I have a static lifetime.&quot;;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time.</p>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>Vectors <code>Vec&lt;T&gt;</code> allow you to store more than on value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
v.push(1);
// ...
// or
let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust provides the <code>vec!</code>macro for convenience.</p>
</blockquote>
<h3 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h3>
<p>There are two ways to reference a value stored in a vector.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];

match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is: {}.&quot;, third);
    None =&gt; println!(&quot;There is no third element.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The first <code>[]</code> method may cause the program to panic if it references a nonexistent element, like <code>&amp;v[100]</code>.
When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking.</p>
</blockquote>
<p>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules to ensure this reference and any other references to the contents of the vector remain valid.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = &amp;v[0];
//           - immutable borrow occurs here
v.push(6);
//^^^^^^^ mutable borrow occurs here
println!(&quot;The first element is: {}&quot;, first);
//                                   ----- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<p>This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space. In that case, the reference to the first element would be pointing to deallocated memory.</p>
<h3 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h3>
<p>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time.</p>
<p>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>To change the value that the mutable reference refers to, we have to use the dereference operator <code>*</code> to get to the value in <code>i</code> before we can use the <code>+=</code> operator.</p>
</blockquote>
<h3 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3>
<p>We said that vectors can only store values that are the same type. Fortunately, the variant of an enum are defined under the same enum type, so when we need to store elements of a different type in vector, we can defined and use an enum.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell:: Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<h2 id="storing-utf-8-encoded-text-with-strings"><a class="header" href="#storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded Text with Strings</a></h2>
<p>Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>.</p>
<p>The <code>String</code> type, which is provided by Rust`s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
s.push_str(&quot;hello&quot;);
let h = s[0];
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s1 = String::from(&quot;tac&quot;);
let s1 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3; // note s1 has been moved here
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>.</p>
</blockquote>
<p>In UTF-8, each Unicode scalar value may takes more than one byte of storage. Think of Cyrillic, Japanese or Hindi signs. Therefore, an index into the string's bytes will not always correlate to a valid Unicode scalar value.</p>
<p>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust's perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>Sometimes when you extract chars from a string, you will have diacritics that do not make sense on their own. So, indexing into a string is often a bad idea because it is not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice.</p>
<p>Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library. You can check the <a href="https://crates.io/crates/unicode-segmentation"><code>unicode-segmentation</code></a> crate.</p>
<blockquote>
<p>Rust has chosen to make the correct handling of <code>String</code> data the default behaviour for all Rust programs, which means programmers have to put more thought into handling UTF-8 data up front. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle</p>
</blockquote>
<h2 id="hash-maps"><a class="header" href="#hash-maps">Hash Maps</a></h2>
<p>The type <code>HashMap&lt;K, V&gt;</code> stores a mapping of keys of type <code>K</code> to values of type <code>V</code>.</p>
<blockquote>
<p>Each key can only have one value associated with it at a time.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Of our three common collections, this one is the least often used, so it is not included in the features brought into scope automatically in the prelude.</p>
</blockquote>
<p>Another way of constructing a hash map is by using the <code>collect</code> method on a vector of tuples, where each tuple consists of a key and its value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = vec![(String::from(&quot;Blue&quot;), 10), (String::from(&quot;Yellow&quot;), 50)].collect();
<span class="boring">}
</span></code></pre></pre>
<p>We could also use the <code>zip</code> method to create a vector of tuples.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>For types that implements the <code>Copy</code>trait, such as <code>i32</code>, the values are copied into the hash map. For owned values such as <code>String</code>, the values will be moved and the hash map will be the owner of those values.</p>
</blockquote>
<h3 id="accessing-values"><a class="header" href="#accessing-values">Accessing Values</a></h3>
<p>We can get a value out of the hash map by proving its key to the <code>get</code> method. The result is wrapped in <code>Some</code> because <code>get</code> returns an <code>Option&lt;&amp;V&gt;</code>.</p>
<p>We can iterates over each key/value pair in a similar manner as we do with vectors, using a <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="updating-a-hash-map"><a class="header" href="#updating-a-hash-map">Updating a Hash Map</a></h2>
<p>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced.</p>
<p>Hash Maps have a special API for inserting a value only if the key has no value, called <code>entry</code>. It takes the key you want to check as a parameter. The return value of the entry method is an enum called <code>Entry</code> that represents a value that might or might not exist.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference (<code>&amp;mut V</code>) to the new value.</p>
<blockquote>
<p>By default, <code>HashMap</code> uses a cryptographically strong hashing function that is not the fastest algorithm available. You can switch to another function by specifying a different <em>hasher</em>. A hasher is a type that implements the <code>BuildHasher</code>trait.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures-and-iterators"><a class="header" href="#closures-and-iterators">Closures and Iterators</a></h1>
<h2 id="closures"><a class="header" href="#closures">Closures</a></h2>
<p>Rust's closures are anonymous functions you can save in a variable or pass as arguments to other functions.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = vec![1, 2, 3, 4]
    .iter()
    .map(|x| x + 3);
<span class="boring">}
</span></code></pre></pre>
<p>To define a closure, we start with a pair of vertical pipes (<code>|</code>), inside which we specify the parameters to the closure. After the parameters, we place curly brackets that hold the body of the closure – these are optional if the closure body is a single expression.</p>
<p>Closures don't require you to annotate the types of the parameters or the return value like <code>fn</code> functions do. But as with variables, we can add type annotations of we want to increase explicitness and clarity at the cost of being more verbose than is strictly necessary.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
let closure_inferred = |i | i + 1 ;
<span class="boring">}
</span></code></pre></pre>
<p>We can defined a closure and store the <em>closure</em> in a variable rather than storing the result of the function call.</p>
<p>The first time we call a closure with any value, the compiler infers the type of it and the return type of the closure. Those types are the locked into the closure and we get a type error if we try to use a different type with the same closure.</p>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the Environment with Closures</a></h3>
<p>Closures have an additional capability that functions don`t have: they can capture their environment and access variables from the scope in which they are defined.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 4;
let equal_to_x = |z| z == x;
let y = 4;
assert!(equal_to_x(y));
<span class="boring">}
</span></code></pre></pre>
<p>Closures can capture values from their environment in three ways, which directly map to the three ways a function can take a parameter: taking ownership, borrowing mutably, and borrowing immutably. These are encoded in the three <code>Fn</code> traits.</p>
<blockquote>
<p>The <code>Fn</code> traits are provided by the standard library. All closures implement at least one of the traits: <code>Fn</code>, <code>FnMut</code> or <code>FnOnce</code>.</p>
</blockquote>
<!-- prettier-ignore -->
<table><thead><tr><th>Trait</th><th>Description</th></tr></thead><tbody>
<tr><td><code>FnOnce</code></td><td>consumes the variables it captures from its enclosing scope, known as closure's <em>environment</em>. To consume the captured variables, the closure must take ownership of these variables and move them into the closure when it is defined. The <code>Once</code> part represents the fact that the closure can not take ownership more than once, so it can be called only once.</td></tr>
<tr><td><code>FnMut</code></td><td>can change the environment be it mutably borrows values</td></tr>
<tr><td><code>Fn</code> </td><td>borrows value from the environment immutability</td></tr>
</tbody></table>
<p>If you want to force the closure to take ownership of the values it uses in the environment, you can use the <code>move</code> keyword before the parameter list.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let equal_to_x = move |z| z == x;
<span class="boring">}
</span></code></pre></pre>
<h2 id="iterators"><a class="header" href="#iterators">Iterators</a></h2>
<p>The iterator pattern allows you to perform some task on a sequence of items in turn. An iterator is responsible for the logic of iterating over each item and determining when the sequence has finished.</p>
<p>In Rust, iterators are <em>lazy</em>, meaning they have no effect until you call methods that consume the iterator to use it up.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let v_iter = v.iter();

for val in v_iter {
	// -- snip --
}
<span class="boring">}
</span></code></pre></pre>
<p>All iterators implement a trait named <code>Iterator</code> that is defined in the standard library.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
	type Item;

	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt;;

	// -- snip --
}
<span class="boring">}
</span></code></pre></pre>
<p>Notice this definition uses some new syntax: <code>type Item</code> and <code>Self::Item</code>, which are defining an <em>associated type</em> with this trait. The <code>Item</code> type will be the type returned from the iterator.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
let mut v_iter = v.iter();

assert_eq!(v_iter.next(), Some(&amp;1));
assert_eq!(v_iter.next(), Some(&amp;2));
assert_eq!(v_iter.next(), Some(&amp;3));
assert_eq!(v_iter.next(), None);
<span class="boring">}
</span></code></pre></pre>
<p>We need to make iterator mutable: calling the <code>next</code> method on an iterator changes internal state that the iterator uses to keep track of where it is in the sequence.</p>
<p>We did not need to make <code>v_iter</code> mutable when we used a <code>for</code> loop because the loop took ownership of <code>v_iter</code> and made it mutable behind the scenes.</p>
<p>The <code>iter</code> method produces an iterator over immutable references. If we want to create an iterator that takes ownership of <code>v</code> and returns owned values, we can call <code>into_iter</code> instead of <code>iter</code>. Similarly, if we want to iterate over mutable references, we can call <code>iter_mut</code> instead of <code>iter</code>.</p>
<h3 id="creating-our-own-iterators"><a class="header" href="#creating-our-own-iterators">Creating our own Iterators</a></h3>
<p>The <code>Iterator</code> trait has a number of different methods with default implementations provided by the standard library. Other methods defined on the <code>Iterator</code>trait, known as <em>iterator adaptors</em>, allow you to change iterators into different kinds of iterators.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Counter {
	count: u32,
}

impl Counter {
	fn new() -&gt; Self {
		Counter { count: 0 }
	}
}

impl Iterator for Counter {
	type Item = u32;

	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
		self.count += 1;

		if self.count &lt; 6 {
			Some{self.count}
		} else {
			None
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>We implemented the <code>Iterator</code> trait by defining the <code>next</code> method, so we can now use any <code>Iterator</code> trait method's default implementations as defined in the standard library, because they all use the <code>next</code> method's functionality.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let sum: u32 = Counter::new().zip(Counter::new().skip(1))
							 .map(|(a, b)| a * b)
							 .filter(|x| x % 3 == 0)
							 .sum();
asset_eq!(sum, 18);
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> Expressions</a></h3>
<p>Blocks of code associated with the conditions in <code>if</code> expressions are sometimes called <em>arms</em>, just like the arm in <code>match</code> expressions. Optionally, we can also include an <code>else</code> expression (or <code>else if</code>). It's also worth noting that the condition <em>must</em> be a <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn eight() -&gt; i32 {
	if true {
		8
	} else {
		4
	}
}

println!(&quot;{}&quot;, eight()); // =&gt; 8
<span class="boring">}
</span></code></pre></pre>
<h4 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h4>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code> statement. Remember that blocks of code evaluate to the last expression in them. This means the values that have the potential to be results from each arm of the <code>if</code> must be the <strong>same type</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = true;
let number = if condition {
	5
} else {
	6
};

println!(number is &quot;{}&quot;, number);
<span class="boring">}
</span></code></pre></pre>
<h3 id="repetitions"><a class="header" href="#repetitions">Repetitions</a></h3>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code> and <code>for</code>.</p>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
	println!(&quot;again!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>You might need to pass the result of a <code>loop</code>. To do this, add the value you want returned after the <code>break</code> expression, you use to stop the loop.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = 0;

let result = loop {
	counter += 1;

	if counter == 10 {
		break counter * 2;
	}
};
<span class="boring">}
</span></code></pre></pre>
<h4 id="conditional-loops-with-while"><a class="header" href="#conditional-loops-with-while">Conditional Loops with <code>while</code></a></h4>
<p>It's often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut number = 3;

while number != 0 {
	number = number - 1;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="looping-through-a-collection-with-for"><a class="header" href="#looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h3>
<p>You can use a <code>for</code> loop and execute some code for each item in a collection. The safety and conciseness of <code>for</code> loops make them the most commonly used loop construct in Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for number in (1..4).rev() {
	println(&quot;{}!&quot;, number);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>.rev()</code> reverses the range</p>
</blockquote>
<h2 id="the-match-control-flow-operator"><a class="header" href="#the-match-control-flow-operator">The match Control Flow Operator</a></h2>
<p>Rust has an extremely powerful control flow operator called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. The power of <code>match</code> comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.</p>
<blockquote>
<p>When the <code>match</code> expression executes, it compares the resulting value against the pattern of each arm, in order.</p>
</blockquote>
<p>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire <code>match</code> expression.</p>
<blockquote>
<p>Curly brackets typically are not used if the match arm code is short.</p>
</blockquote>
<p>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</p>
<p>Combining <code>match</code> and enums is useful in many situation. You will see this pattern a lot in Rust code: match against an enum, bind a variable to the data inside, and then execute code based on it.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number {
	odd: bool,
	value: i32,
}

let one = Number { odd: true, value: 1 };
let two = Number { odd: false, value: 2 };

print_number(one); // =&gt; Odd number: 1
print_number(two); // =&gt; Even number: 2

// Same as with the if pattern
fn print_number(n: Number) {
	match n {
		Number { odd: true, value } =&gt; println!(&quot;Odd number: {}&quot;, value),
		Number { odd: false, value } =&gt; println!(&quot;Even number: {}&quot;, value),
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>One requirement for <code>match</code> expressions is that they need to be <em>exhaustive</em>. At least one arm needs to match.
One way to ensure you have covered every possibility is to have a catchall pattern for the last arm. A particular pattern <code>_</code> will match anything, but it never binds to a variable.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_number(n: Number) {
	match n.value {
		1 =&gt; println!(&quot;One&quot;),
		2 =&gt; println!(&quot;Two&quot;),
		_ =&gt; (),
	}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The <code>()</code> is just the unit value, so nothing will happen in the <code>_</code> case here.</p>
</blockquote>
<h3 id="pattern-syntax"><a class="header" href="#pattern-syntax">Pattern syntax</a></h3>
<h4 id="literals"><a class="header" href="#literals">Literals</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 =&gt; println!(&quot;one&quot;)
<span class="boring">}
</span></code></pre></pre>
<h4 id="named-variables"><a class="header" href="#named-variables">Named Variables</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Some(x) =&gt; println!(&quot;x = {}&quot;, x)
<span class="boring">}
</span></code></pre></pre>
<h4 id="multiple"><a class="header" href="#multiple">Multiple</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1 | 2 =&gt; println!(&quot;one or two&quot;)
<span class="boring">}
</span></code></pre></pre>
<h4 id="range-with-the--syntax"><a class="header" href="#range-with-the--syntax">Range with the ..= Syntax</a></h4>
<p>Ranges are only allowed with numeric values or <code>char</code> values, because the compiler checks that the range isn’t empty at compile time.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>1..=5 =&gt; println!(&quot;one through five&quot;),
'a'..='j' =&gt; println!(&quot;early ASCII letter&quot;),
<span class="boring">}
</span></code></pre></pre>
<h3 id="match-guard"><a class="header" href="#match-guard">Match guard</a></h3>
<p>A <em>match guard</em> is an additional <code>if</code> condition specified after the pattern in a <code>match</code> arm that must also match, along with the pattern matching, for that arm to be chosen. Match guards are useful for expressing more complex ideas than a pattern alone allows.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let num = Some(4);

    match num {
        Some(x) if x % 2 == 0 =&gt; println!(&quot;The number {} is even&quot;, x),
        Some(x) =&gt; println!(&quot;The number {} is odd&quot;, x),
        None =&gt; (),
    }
}
</code></pre></pre>
<h3 id="-bindings"><a class="header" href="#-bindings">@ Bindings</a></h3>
<p>The <code>at</code> operator (<code>@</code>) lets us create a variable that holds a value at the same time we are testing that value to see whether it matches a pattern.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>match msg {
	Message::Hello {
		id: id_variable @ 3..=7,
	} =&gt; println!(&quot;Found an id in range: {}&quot;, id_variable),
	Message::Hello { id: 10..=12 } =&gt; {
		println!(&quot;Found an id in another range&quot;)
	}
	Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="concise-control-flow-with-if-let-and-while-let"><a class="header" href="#concise-control-flow-with-if-let-and-while-let">Concise Control Flow with if let and while let</a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
<blockquote>
<p><code>if let</code> can also introduce shadowed variables in the same way that <code>match</code> arms can: <code>if let Ok(age) = age</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Some(40);
let b = None;

print_number(a); // =&gt; 40
print_number(b); // =&gt; No output

fn print_number(n: Option&lt;i32&gt;) {
	if let Some(value) = n {
		println!(&quot;{}&quot;, value)
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Similar in construction to <code>if let</code>, the <code>while let</code> conditional loop allows a while loop to run for as long as a pattern continues to match.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>while let Some(top) = stack.pop() {
	println!(&quot;{}&quot;, top);
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h1>
<p>Just some ideas for research:</p>
<ul>
<li>Threads</li>
<li>Parallelization (rayon create)</li>
<li>SIMD / Vectorization
<ul>
<li>https://github.com/rust-lang/portable-simd</li>
<li>https://doc.rust-lang.org/nightly/std/simd/index.html</li>
<li>https://ianjk.com/terrain_generator/</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-and-modules"><a class="header" href="#crates-and-modules">Crates and Modules</a></h1>
<p>Rust has a specific way of declaring things.</p>
<p>By default, Rust brings only a few types into the scope of every program in the prelude. If a type you want to use is not in the prelude, you have to bring that type into scope explicitly with a <code>use</code> statement.</p>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>The double colon <code>::</code> is an operator that allows us to namespace this particular <code>from</code> function under the <code>String</code> type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>String::from(&quot;Hey&quot;);
<span class="boring">}
</span></code></pre></pre>
<h3 id="crate"><a class="header" href="#crate">Crate</a></h3>
<p>A crate may contains a lot of modules. A crate is a folder where, in its root, you have a <code>Cargo.toml</code> file.</p>
<blockquote>
<p>You can compare it to package.json in the JavaScript world, although we used to call it a node module. You import it with a single name, the node module name.</p>
</blockquote>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<ul>
<li>A module is a file.</li>
<li>Or a folder with a mod.rs file inside.</li>
</ul>
<blockquote>
<p>In the JavaScript world this is a module, or an ES module. This is when you import a file with a relative path instead of a name.</p>
</blockquote>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<p>Every module exports functions.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::cmp::min(3, 8); // =&gt; 3
use std::cmp::*
<span class="boring">}
</span></code></pre></pre>
<h3 id="types-are-namespace-too"><a class="header" href="#types-are-namespace-too">Types are namespace too</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;rust&quot;.len(); // =&gt; 4
let x = str::len(&quot;rust&quot;); // =&gt; 4
<span class="boring">}
</span></code></pre></pre>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Rust inserts this at the beginning of every module.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::prelude::v1::*;
<span class="boring">}
</span></code></pre></pre>
<p>So that, instead of <code>std::vec::Vec::new()</code>, you can use <code>Vec::new()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-crates"><a class="header" href="#useful-crates">Useful Crates</a></h1>
<p>This list is obviously very <strong>opiniated</strong> and <strong>not complete</strong>. It's a list a useful crates I discovered while using
Rust. Some better-known crates are not displayed below, because I prefer the ones listed here.</p>
<h2 id="general-purpose"><a class="header" href="#general-purpose">General purpose</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/futures">futures</a></td><td>Futures and streams featuring zero allocations, composability, and iterator-like interfaces.</td></tr>
<tr><td><a href="https://crates.io/crates/itertools">itertools</a></td><td>Extra iterator adaptors, iterator methods, free functions, and macros.</td></tr>
<tr><td><a href="https://crates.io/crates/lazy_static">lazy_static</a></td><td>A macro for declaring lazily evaluated statics in Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/rayon">rayon</a></td><td>Simple work-stealing parallelism for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/serde">serde</a></td><td>A generic serialization/deserialization framework.</td></tr>
<tr><td><a href="https://crates.io/crates/serde_json">serde_json</a></td><td>A JSON serialization file format.</td></tr>
<tr><td><a href="https://crates.io/crates/tokio">tokio</a></td><td>An event-driven, non-blocking I/O platform for writing asynchronous I/O backed applications.</td></tr>
</tbody></table>
<h2 id="math-physics-geo-bio"><a class="header" href="#math-physics-geo-bio">Math, Physics, Geo, Bio</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/bio">bio</a></td><td>A bioinformatics library for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/geo">geo</a></td><td>Geospatial primitives and algorithms.</td></tr>
<tr><td><a href="https://crates.io/crates/nalgebra">nalgebra</a></td><td>General-purpose linear algebra library with transformations and statically-sized or dynamically-sized matrices. <a href="https://dimforge.com">Dimforge</a></td></tr>
<tr><td><a href="https://crates.io/crates/num">num</a></td><td>A collection of numeric types and traits (bigint, complex, rational, range iterators, generic integers...)</td></tr>
<tr><td><a href="https://crates.io/crates/parry2d">parry2d</a></td><td>2 dimensional collision detection library in Rust. <a href="https://dimforge.com">Dimforge</a></td></tr>
<tr><td><a href="https://crates.io/crates/rand">rand</a></td><td>Random number generators and other randomness functionality.</td></tr>
</tbody></table>
<h2 id="string-encoding-time-and-crypto"><a class="header" href="#string-encoding-time-and-crypto">String, Encoding, Time and Crypto</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/chrono">chrono</a></td><td>Date and time library for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/crypto">crypto</a></td><td>Resources for building cryptosystems in Rust using the RustCrypto project's ecosystem.</td></tr>
<tr><td><a href="https://crates.io/crates/data-encoding">data-encoding</a></td><td>Data-encoding functions like base64, base32, and hex.</td></tr>
<tr><td><a href="https://crates.io/crates/fluent">fluent</a></td><td>A localization system designed to unleash the entire expressive power of natural language translations.</td></tr>
<tr><td><a href="https://crates.io/crates/regex">regex</a></td><td>An implementation of regular expressions for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/unicode-segmentation">unicode-segmentation</a></td><td>Grapheme Cluster, Word and Sentence boundaries according to Unicode Standard Annex #29 rules.</td></tr>
<tr><td><a href="https://crates.io/crates/uuid">uuid</a></td><td>A library to generate and parse UUIDs.</td></tr>
</tbody></table>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/dotenvy">dotenvy</a></td><td>A <code>dotenv</code> implementation for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/roxmltree">roxmltree</a></td><td>Represent an XML as a read-only tree.</td></tr>
<tr><td><a href="https://crates.io/cratess/ron">ron</a></td><td>Rusty Object Notation</td></tr>
<tr><td><a href="https://crates.io/crates/toml">toml</a></td><td>A native Rust encoder and decoder of TOML-formatted files and streams.</td></tr>
</tbody></table>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/clap-rs/clap">clap</a></td><td>Command Line Argument Parser for Rust.</td></tr>
<tr><td><a href="https://github.com/mitsuhiko/console">console</a></td><td>A Rust console and terminal abstraction.</td></tr>
<tr><td><a href="https://github.com/rust-lang/log">log</a></td><td>A Rust library providing a lightweight logging facade.</td></tr>
</tbody></table>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/slab">slab</a></td><td>Pre-allocated storage for a uniform data type.</td></tr>
<tr><td><a href="https://crates.io/crates/sqlx">sqlx</a></td><td>An async SQL crate. Supports PostgreSQL, MySQL, and SQLite.</td></tr>
</tbody></table>
<h2 id="graphics-and-ui"><a class="header" href="#graphics-and-ui">Graphics and UI</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/image">image</a></td><td>Imaging library written in Rust. Provides basic filters and decoders for the most common image formats.</td></tr>
<tr><td><a href="https://crates.io/crates/piet">piet</a></td><td>An abstraction for 2D graphics.</td></tr>
<tr><td><a href="https://crates.io/crates/piet-svg">piet-svg</a></td><td>SVG backend for piet 2D graphics abstraction.</td></tr>
</tbody></table>
<h2 id="web"><a class="header" href="#web">Web</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/async-graphql">async-graphql</a></td><td>A GraphQL server library implemented in Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/axum">axum</a></td><td>Web framework that focuses on ergonomics and modularity.</td></tr>
<tr><td><a href="https://crates.io/crates/hyper">hyper</a></td><td>A fast and correct HTTP library.</td></tr>
<tr><td><a href="https://crates.io/crates/jsonwebtoken">jsonwebtoken</a></td><td>Create and decode JWTs in a strongly typed way.</td></tr>
<tr><td><a href="https://crates.io/crates/lettre">lettre</a></td><td>Email client</td></tr>
<tr><td><a href="https://crates.io/crates/reqwest">reqwest</a></td><td>Higher level HTTP client library.</td></tr>
<tr><td><a href="https://crates.io/crates/tower">tower</a></td><td>Tower is a library of modular and reusable components for building robust clients and servers.</td></tr>
<tr><td><a href="https://crates.io/crates/tower-http">tower-http</a></td><td>Tower middleware and utilities for HTTP clients and servers.</td></tr>
<tr><td><a href="https://crates.io/crates/async-tungstenite">tungstenite</a></td><td>Async binding for Tungstenite, the Lightweight stream-based WebSocket implementation.</td></tr>
</tbody></table>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/console_error_panic_hook">console_error_panic_hook</a></td><td>A panic hook for <code>wasm32-unknown-unknown</code> that logs panics to <code>console.error</code>.</td></tr>
<tr><td><a href="https://crates.io/crates/js-sys">js-sys</a></td><td>Bindings for all JS global objects and functions in all JS environments.</td></tr>
<tr><td><a href="https://crates.io/crates/piet-web">piet-web</a></td><td>Web canvas backend for piet 2D graphics abstraction.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen</a></td><td>Easy support for interacting between JS and Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen-futures">wasm-bindgen-futures</a></td><td>Bridging the gap between Rust Futures and JavaScript Promises.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen-rayon">wasm-bindgen-rayon</a></td><td>Adapter for using Rayon-based concurrency on the Web.</td></tr>
<tr><td><a href="https://crates.io/crates/web-sys">web-sys</a></td><td>Bindings for all Web APIs.</td></tr>
<tr><td><a href="https://crates.io/crates/wee_alloc">wee_alloc</a></td><td>The Wasm-Enabled, Elfin Allocator.</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rustup"><a class="header" href="#rustup">Rustup</a></h1>
<p><a href="https://rustup.rs"><code>rustup</code></a> installs The Rust Programming Language from the official release channels, enabling you to easily switch between stable, beta, and nightly compilers and keep them updated. It makes cross-compiling simpler with binary builds of the standard library for common platforms. And it runs on all platforms Rust supports.</p>
<p><a href="https://rustup.rs"><code>rustup</code></a> is a toolchain multiplexer. It installs and manages many Rust toolchains and presents them all through a single set of tools installed to <code>~/.cargo/bin</code>. The <a href="https://doc.rust-lang.org/rustc/"><code>rustc</code></a> and <a href="https://doc.rust-lang.org/cargo/"><code>cargo</code></a> executables installed in <code>~/.cargo/bin</code> are proxies that delegate to the real toolchain. rustup then provides mechanisms to easily change the active toolchain by reconfiguring the behavior of the proxies.</p>
<p>This is similar to Ruby's <code>rbenv</code>, Python's <code>pyenv</code>, or Node's <code>nvm</code>.</p>
<p>See more on the <a href="https://rust-lang.github.io/rustup/index.html"><code>rustup</code> documentation</a>.</p>
<h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p>Cargo is the Rust package manager. Cargo downloads your Rust package's dependencies, compiles your packages, makes distributable packages, and uploads them to <a href="https://crates.io">crates.io</a>, the Rust community’s package registry.</p>
<p>See more on the <a href="https://doc.rust-lang.org/cargo/index.html"><code>cargo</code> documentation</a></p>
<p>You can use <code>cargo new</code> or <code>cargo init</code> to start a new project.</p>
<h2 id="running-and-building"><a class="header" href="#running-and-building">Running and Building</a></h2>
<p><code>cargo run</code> is probably the first command you want to use in order to see the output of your software. It runs a binary or example of the local package. All the arguments following the two dashes (<code>--</code>) are passed to the binary to run.</p>
<p><code>cargo build</code> compiles local packages and all of their dependencies.</p>
<h2 id="checking-and-linting"><a class="header" href="#checking-and-linting">Checking and Linting</a></h2>
<p><code>cargo check</code> checks a local package and all of its dependencies for errors. This will essentially compile the packages without performing the final step of code generation, which is faster.</p>
<p><code>cargo fix</code> automatically takes rustc's suggestions from diagnostics like warnings and apply them to your source code. This is intended to help automate tasks that rustc itself already knows how to tell you to fix!</p>
<h3 id="clippy"><a class="header" href="#clippy">Clippy</a></h3>
<p>Clippy is a linter which is more features complete than what the compiler can provide with <code>cargo check</code> or <code>cargo fix</code>.</p>
<p>It is usually installed thanks to <code>rustup</code> and you can lint your code with <code>cargo clippy</code>. In order to apply the fix, run <code>cargo clippy --fix</code></p>
<p>Usually Clippy is well integrated into the IDE but needs to be activated. As you can imagine it needs more power and time to run properly, but beleave me, it's an incredible tool.</p>
<p>See more on the <a href="https://github.com/rust-lang/rust-clippy">Clippy GitHub repository</a></p>
<h2 id="extend-cargo"><a class="header" href="#extend-cargo">Extend Cargo</a></h2>
<p>Cargo can be extanded via plugin. The most useful one is probably <code>cargo-edit</code> which allow you to add, remove, and upgrade dependencies by modifying your <code>Cargo.toml</code> file from the command line. You can simply install it by running <code>cargo install cargo-edit</code>.</p>
<p>See more on the <a href="https://crates.io/crates/cargo-edit">cargo-edit crate page</a>.</p>
<h2 id="other"><a class="header" href="#other">Other</a></h2>
<p>Cargo can also run examples, do testing, create documentation, do some benchmarking and even more. Some of those possibilities are detailed in the next chapters.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
