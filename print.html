<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Concise Rust &amp; WebAssembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-01-foreword.html">Foreword</a></li><li class="chapter-item expanded "><a href="ch01-00-rust-history.html"><strong aria-hidden="true">1.</strong> Concise Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-variables-data-types.html"><strong aria-hidden="true">1.1.</strong> Variables and Data Types</a></li><li class="chapter-item expanded "><a href="ch01-02-functions-block-scope.html"><strong aria-hidden="true">1.2.</strong> Functions, Blocks and Scope</a></li><li class="chapter-item expanded "><a href="ch01-03-ownership-borrowing-slices.html"><strong aria-hidden="true">1.3.</strong> Ownership, Borrowing and Slices</a></li><li class="chapter-item expanded "><a href="ch01-04-structs-enums-implementation.html"><strong aria-hidden="true">1.4.</strong> Struct, Enums and Implementation</a></li><li class="chapter-item expanded "><a href="ch01-05-generics-traits-lifetimes.html"><strong aria-hidden="true">1.5.</strong> Generics, Traits and Lifetimes</a></li><li class="chapter-item expanded "><a href="ch01-06-control-flow.html"><strong aria-hidden="true">1.6.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="ch01-07-collections.html"><strong aria-hidden="true">1.7.</strong> Collections</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Concise WebAssembly</div></li><li class="chapter-item expanded "><a href="ch03-00-crates-modules.html"><strong aria-hidden="true">3.</strong> Crates and Modules</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-xx-useful-crates.html"><strong aria-hidden="true">3.1.</strong> Useful Crates</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concise Rust &amp; WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cedeber/concise-rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p>Hello. I hope this book finds you well.</p>
<p>As a non-daily rustacean - I am a daily TypeScript developer and UI designer -, coming back to Rust only from time to
time is sometimes painful. I tend to forget how to code with Rust. Although it is a very nice language, it is also a
complex and explicit language. There is a lot to keep in mind.</p>
<p>This little book is the book I want to always have with me when I code with Rust. Unfortunately, it will not cover
everything about Rust but, for sure, enough to let you code any kind of high-level application. If you want to go unsafe
and manage the memory yourself, this book will certainly not cover what you need. To be fair, at this level of
understanding of the language, you probably do not need this book anyway. I will assume, though, that you have already
coded before, at least with another C-like language. I hope this book will help you as much as I had fun writing it.</p>
<p><em>‚Äî <a href="https://www.cedeber.fr">C√©dric Eberhardt</a></em>.</p>
<blockquote>
<p>Don't hesitate to <a href="https://github.com/cedeber/concise-rust-book">contribute</a> if you are missing something or if I did
a mistake, which is to expect, as I still consider myself as a Rust beginner. Thank you in advance for the help.</p>
</blockquote>
<p>If you want to play a bit with Rust without installing it, there is a <a href="https://play.rust-lang.org">Rust Playground</a> for
that.</p>
<h2 id="inspiration-and-references"><a class="header" href="#inspiration-and-references">Inspiration and references</a></h2>
<ul>
<li><a href="https://doc.rust-lang.org/stable/book/">The official Rust Book</a>, of course, from which I shamelessly copy the important parts to create this best-of concise book. It is very well written and a must-read recommendation if I convince you to learn more about Rust.</li>
<li><a href="https://fasterthanli.me/articles/a-half-hour-to-learn-rust">A half-hour to learn Rust</a>
from <a href="https://fasterthanli.me">amos</a></li>
<li>...</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concise-rust"><a class="header" href="#concise-rust">Concise Rust</a></h1>
<h2 id="short-history-of-rust"><a class="header" href="#short-history-of-rust">Short history of Rust</a></h2>
<p>Rust began, in 2006, as a side project of Graydon Hoare, an employee at Mozilla. Mozilla believed in the potential of
this new language and began sponsoring it. It was revealed to the world in 2010.</p>
<p>According to Hoare, the name of the language comes from the rust fungus. This has caused Rust programmers to adopt
‚ÄúRustaceans‚Äù as their nickname of choice.</p>
<p>In mid-2020, following the layoffs at Mozilla, the Rust core team said they were considering a new Rust foundation to
boost Rust independence. It was officially announced in February 2021.</p>
<h3 id="editions"><a class="header" href="#editions">Editions</a></h3>
<ul>
<li>Rust 2015: <code>1.0</code> (cargo‚Äôs <code>edition</code> has been introduced in 2017)</li>
<li>Rust 2018: <code>1.31</code> or <code>edition=&quot;2018&quot;</code></li>
<li>Rust 2021: <code>1.56</code> or <code>edition=&quot;2021&quot;</code></li>
</ul>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Rust is a very nice language. It has been designed to cover most development areas, from an easy CLI application to
system programming. And all of that with <strong>safety</strong>, <strong>control</strong> and <strong>productivity</strong> in mind.</p>
<p>Regarding safety, you can think of Python, and for control, C. Rust is some kind of mix of the best of both of these
worlds. While I do not think Rust is a good replacement for Python as such, it is for sure a perfect replacement for C
or any low-level languages, with the safety and fun of Python, but without trading the <strong>performance</strong> of C-like
languages at the same time.</p>
<p>A more personal point of view, what I like too, is the fact that Rust is an <strong>explicit</strong> language. There is no magic.
What you read if what it is going to happen. There are no tricks, like for instance in JavaScript, where Array and
Object are passed by reference. If you don't know that, you will have weird side effects. In Rust you always know what
happens, even with mutability. You will definitely code with <strong>confidence</strong>.</p>
<blockquote>
<p>The Rust programming language is fundamentally about empowerment: no matter what kind of code you are writing, Rust
empowers you to reach further, to program with confidence in a wide variety of domains than you did before.</p>
<p>‚Äî <em>Foreword from the Rust programming language book.</em></p>
</blockquote>
<p>In the other hand, it makes things a little bit more complex and <strong>noisy</strong>.
Well, this is the reason of this book and why Rust is known to have a steep learning curve.</p>
<h3 id="what-makes-it-different-to-most-of-common-programming-languages"><a class="header" href="#what-makes-it-different-to-most-of-common-programming-languages">What makes it different to most of common programming languages?</a></h3>
<ul>
<li>It does <strong>not have a garbage collector</strong>. But you can still choose how the memory is managed. And you do not have to
free the memory yourself. It has a lot of smart pointers for <strong>memory efficiency</strong>.</li>
<li>Because of how memory is managed - the <strong>ownership</strong> principle - it is <strong>memory and thread safe</strong>. There are no
dangling pointers, no data race, no buffer overflow, no iterator invalidation.</li>
<li>It keeps <strong>performance</strong>, very close to what C can offer. Even sometimes faster.</li>
<li>No <code>null</code> pointer exceptions.</li>
<li>No <code>class</code> and so, no <code>inheritance</code>.</li>
<li>First-class <strong>WebAssembly</strong> support.</li>
</ul>
<h3 id="ecosystem"><a class="header" href="#ecosystem">Ecosystem</a></h3>
<p>Last but not least, although not related to the Rust language itself, the whole ecosystem and tooling around Rust is
just awesome. It is definitely feature-complete:</p>
<ul>
<li>A complete ecosystem (<code>rustup</code>, <code>cargo</code>, <code>crates</code>, <code>rustfmt</code>, <code>clippy</code>, ...)</li>
<li>Good IDE support (IntelliJ-based and VSCode)</li>
<li>Documentation directly in source code, from the comments</li>
<li>Examples folder managed with <code>cargo</code></li>
<li>Tests in source code and <code>cargo test</code></li>
<li><code>cargo</code> can be expanded: <code>cargo-edit</code>, <code>cargo-watch</code>, ...</li>
<li>Compiler giving hints thanks to <code>clippy</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-and-data-types"><a class="header" href="#variables-and-data-types">Variables and Data types</a></h1>
<h2 id="variable-binding-and-type-inference"><a class="header" href="#variable-binding-and-type-inference">Variable binding and Type inference</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = bar;
<span class="boring">}
</span></code></pre></pre>
<p>This line creates a new variable named <code>foo</code> and binds it to the value of the <code>bar</code> variable.</p>
<p>You don't need to define the type on assignment. But you must assign a value before usage. The compiler can usually
infer what type we want to use based on the value and how we use it.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let str; // declare str
str = &quot;Hello, world!&quot;; // assignement -&gt; &amp;str

let a = 40_000; // -&gt; i32
let b = 40.; // -&gt; f64
let v: [_; 5] = [3; 5];
//      ^ infers type for usage

let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>The binding can be done at a later stage.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a;
// ... some code
a = 42;
<span class="boring">}
</span></code></pre></pre>
<p>Of course, you can still specify the type manually.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i32 = 45;
<span class="boring">}
</span></code></pre></pre>
<h3 id="unused-variables"><a class="header" href="#unused-variables">Unused variables</a></h3>
<p>While you are coding, you can say the compiler to not complain about a variable not being used.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _unused_variable = 42;
<span class="boring">}
</span></code></pre></pre>
<h3 id="throw-away-a-value"><a class="header" href="#throw-away-a-value">Throw away a value</a></h3>
<p>During destructuring, if you don't want to deal with all values you can omit some with an underscore.
In use with the rest operator <code>..</code> it's very easy to just export what you need.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let _ = get_stuff(); // throws away the returned value

// The value 3 and the rest will not be assigned to a variable
let (_, b, ..) = (3, 7, 14, 45);
let (width, _) = get_size();
<span class="boring">}
</span></code></pre></pre>
<h2 id="data-types"><a class="header" href="#data-types">Data types</a></h2>
<p>The types covered here are all stored on the stack.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<p>A <em>scalar</em> type represents a single value. Rust has four primary scalar types: <strong>integers</strong>, <strong>floating point numbers</strong>
, <strong>booleans</strong> and <strong>characters</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: isize = 98_222;
let byt = b'A' // u8 only
let x = 2.0 // f64

let t: bool = true
<span class="boring">}
</span></code></pre></pre>
<p>When you are compiling in release mode, Rust does not checks for integers overflow. If you want to wrap explicitly, you
can use the standard library type <code>Wrapping</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let zero = 0u8;

println!(&quot;{}&quot;, zero - 1_u8);
//             ^^^^^^^^^^^ attempt to compute `0_u8 - 1_u8`, which would overflow
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::num::Wrapping;
</span>let zero = Wrapping(0u8);
let one = Wrapping(1u8);

println!(&quot;{}&quot;, (zero - one).0); // -&gt; 255
<span class="boring">}
</span></code></pre></pre>
<p>Rust‚Äôs char type is four bytes in size and represents a Unicode Scalar Value, which means it can represent a lot more
than just ASCII. Accented letters; Chinese, Japanese and Korean characters; emoji; and zero-width spaces are all valid
char values in Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let heart_eyed_cat = 'üòª';
<span class="boring">}
</span></code></pre></pre>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<p>Rust has two primitive compound types: <strong>tuples</strong> and <strong>arrays</strong>.</p>
<h4 id="the-tuple-type"><a class="header" href="#the-tuple-type">The Tuple Type</a></h4>
<p>This is a fixed length collections of values of different types.
We can access a tuple element directly bu using a <code>.</code> followed by the index of the value we want to access. The first
index in a tuple is <code>0</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tupl = ('x', 32); // =&gt; (char, i32)
let x = tupl.0; // =&gt; 'x'
let thirty_two = tupl.1; // =&gt; 32
<span class="boring">}
</span></code></pre></pre>
<p>As we will see in the &quot;pattern&quot; chapter, you can use <em>pattern matching</em> to desctructure a tuple value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let tup = (500, 6.4, 1);
let (x, y, z) = tup;
<span class="boring">}
</span></code></pre></pre>
<h4 id="the-array-type"><a class="header" href="#the-array-type">The Array Type</a></h4>
<p>Arrays in Rust have a fixed length, like tuples. Arrays are useful when you want your data allocated on the stack rather
than the heap.
You can access elements of an array using indexing. As for tuple, the first index is <code>0</code>. If the index is greater than or
equal to the length, Rust will panic because of Rust's safety principle.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];

let first = a[0];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>An array is not as flexible as the vector type. A vector (<code>Vec</code>) is a similar collection type provided by the standard
library that is allowed to grow or shrink in size.</p>
</blockquote>
<h2 id="immutable-by-default"><a class="header" href="#immutable-by-default">Immutable by default</a></h2>
<p>Mutability in Rust is explicit. When a variable le is immutable, once a value is bound to a name, you can‚Äôt change the
value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number { value: i32 }

let foo = 32;
foo = 40; // Nope

let n = Number {
    value: 3
};
n.value = 5; // Nope
n = Number { value: 5 } // Nope
<span class="boring">}
</span></code></pre></pre>
<p>Let's make it <strong>mutable</strong>. The entire instance must be mutable; Rust does not allow us to mark only certain fields as mutable.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number { value: i32 }

let mut foo = 32;
foo = 40; // Yep

let mut n = Number {
    value: 3
};
n.value = 5; // Yep
n = Number { value: 5 } // Yep
<span class="boring">}
</span></code></pre></pre>
<h3 id="mutable-reference"><a class="header" href="#mutable-reference">Mutable reference</a></h3>
<blockquote>
<p>Of course this in not a good practice and a function should avoid to have side effect like this. But sometimes this is
needed, like when you want to update a graphical context for example.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This function will have side effects
fn change(a: &amp;mut i32) {
    *a = 5
}

let mut a: i32 = 3;
change(&amp;mut a); // Explicit mutability. You have been warned.

println!(&quot;{}&quot;, a); // =&gt; 5
<span class="boring">}
</span></code></pre></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Constants are like immutable variables, but there are some differences:</p>
<ul>
<li>Declared using the const keyword.</li>
<li>The type must be annotated. You can not infer it.</li>
<li>You are not allowed to use mut with constants.</li>
<li>Set only to a constant expression, not to the result of a function call or any other value that could only be computed
at runtime.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const MAX_POINTS: u32 = 100_000;
<span class="boring">}
</span></code></pre></pre>
<h2 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h2>
<p>Shadowing is different from marking a variable as <code>mut</code>, because we will get a compile-time error if we accidentally try
to reassign to this variable without using the <code>let</code> keyword. By using let, we can perform a few transformations on a
value but have the variable be immutable after those transformations have been completed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 32;
let x = 32 + 8; // still immutable!

println!(&quot;{}&quot;, x); // =&gt; 40. Only the last x will be available
<span class="boring">}
</span></code></pre></pre>
<p>Even with a different type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 32;
let x = &quot;Hey&quot;;

println!(&quot;{x}&quot;); // =&gt; &quot;Hey&quot;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-blocks-and-scope"><a class="header" href="#functions-blocks-and-scope">Functions, Blocks and Scope</a></h1>
<p>A pair of brackets declares a block, which has its own scope. It can evaluate to a value and can contain multiple statements.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let x = &quot;out&quot;;
	{
		// this is a different `x`
		let x = &quot;in&quot;;
		println!(&quot;{x}&quot;); // =&gt; in
	}
	println!(&quot;{x}&quot;); // =&gt; out
}
</code></pre></pre>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>Functions are pervasive in Rust code. The <code>main</code> function is the most important function in the language. It's the entry
point of many programs.</p>
<p>The <code>fn</code> keyword allows you to declare new functions. Rust code uses <em>snake case</em> as the conventional style for
functions and variables names. Every function returns by default a <strong>unit</strong> type, written <code>()</code>. It's an empty tuple. No
need to specify it or return
it, it is implicit.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	// empty
}
</code></pre></pre>
<blockquote>
<p>Rust does not care where you define your functions, only that they are defined somewhere.</p>
</blockquote>
<h3 id="parameters"><a class="header" href="#parameters">Parameters</a></h3>
<p>In function signatures, you <em>must</em> declare the type of each parameter.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn another_function(x: i32, y: i32) {
	println!(&quot;x: {}&quot;, x);
	println!(&quot;y: {}&quot;, y);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="return-value"><a class="header" href="#return-value">Return value</a></h3>
<p>We do declare their type after an arrow <code>-&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add(x: i32, y: i32) -&gt; i32 {
	return x + y;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="statements-and-expressions-in-function-bodies"><a class="header" href="#statements-and-expressions-in-function-bodies">Statements and Expressions in Function Bodies</a></h3>
<p>Rust is an expression-based language. <em>Statements</em> are instructions that perform some action and do not return a value. For instance, the <code>let y = 6</code> statement does not return a value. <em>Expressions</em> evaluate to a resulting value. Calling a function is an expression. Calling a macro is an expression. The block that we use to create new scopes, <code>{}</code>, is an expression.</p>
<blockquote>
<p>Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it into a statement, which will then not return a value.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn add_2(a: i32) -&gt; i32 {
	a + 2
}

println!(&quot;{}&quot;, add_2(5)); // =&gt; 7
<span class="boring">}
</span></code></pre></pre>
<h3 id="closure"><a class="header" href="#closure">Closure</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = vec![1, 2, 3, 4]
    .iter()
    .map(|x| x + 3);

let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
let closure_inferred = |i | i + 1 ;
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-borrowing-and-slices"><a class="header" href="#ownership-borrowing-and-slices">Ownership, Borrowing and Slices</a></h1>
<p>Ownership is the most unique feature of Rust, and it enables Rust to make memory safety guarantees without needing a garbage collector.</p>
<blockquote>
<p>Don‚Äôt try to fight against the borrow checker.</p>
</blockquote>
<h2 id="the-stack-and-the-heap"><a class="header" href="#the-stack-and-the-heap">The Stack and the Heap</a></h2>
<p>The <em>stack</em> stores values in the order it gets them and removes the values in the opposite order. This is referred to as <em>last in, first out</em>. All data stored in the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>The <em>heap</em> is less organised. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap.</p>
<p>Pushing to the stack is faster than allocating on the heap because the operating system never has to search for a place to store new data. Comparatively, allocating space on the heap requires more work, because the operating system must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.</p>
<p>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory.</p>
<h2 id="memory-and-allocation"><a class="header" href="#memory-and-allocation">Memory and Allocation</a></h2>
<p>In the case of a string literal, we know the content at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient.</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the content.</p>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <code>drop</code>. Rust call <code>drop</code> automatically at the closing curly bracket.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::From(&quot;hello&quot;);
s.push_str(&quot;, world!&quot;); // appends a literal to a String
println!(&quot;{}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<h3 id="move"><a class="header" href="#move">Move</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>bind the value 5 to <code>x</code>; then make a <strong>copy</strong> of the value in <code>x</code> and bind it to <code>y</code>.</p>
</blockquote>
<p>This is indeed what is happening, because integers are simple values with a known, fixed size and these two 5 values are pushed on the <strong>stack</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>A <code>String</code> is made of three parts: a <em>pointer</em> to the memory that holds the content of the string, a <em>length</em>, and a <em>capacity</em>.</p>
<div style="display: flex; gap: 40px; justify-content: center;">
<div>
<p style="text-align: center;">s1</p>
<table><thead><tr><th>name</th><th>value</th></tr></thead><tbody>
<tr><td>ptr</td><td>‚Üí</td></tr>
<tr><td>len</td><td>5</td></tr>
<tr><td>capacity</td><td>5</td></tr>
</tbody></table>
</div>
<div>
<p style="text-align: center;">data</p>
<table><thead><tr><th>index</th><th>value</th></tr></thead><tbody>
<tr><td>0</td><td>h</td></tr>
<tr><td>1</td><td>e</td></tr>
<tr><td>2</td><td>l</td></tr>
<tr><td>3</td><td>l</td></tr>
<tr><td>4</td><td>o</td></tr>
</tbody></table>
</div>
</div>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the pointer, the length, and the capacity that are on the <strong>stack</strong>.
<em>We do not copy the data on the heap that the pointer refers to</em>.</p>
<p>Again, when a variable goes out of scope, Rust automatically calls the <code>drop</code> function and cleans up the heap memory for that variable.
When s2 and s1 go out of scope, they will both try to free the same memory. This is known as a <em>double free</em> error and is one of the memory safety bugs.</p>
<p>Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and, therefore, Rust doesn't need to free anything when s1 goes out of scope.</p>
<p>If you‚Äôve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of calling it a shallow copy, it‚Äôs known as a <em>move</em>.</p>
<blockquote>
<p>Rust will never automatically create ‚Äúdeep‚Äù copies of your data. Therefore, any <em>automatic</em> copying can be assumed to be inexpensive in terms of runtime performance.</p>
</blockquote>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being executed and that code may be expensive. It‚Äôs a visual indicator that something different is going on.</p>
<h3 id="stack-only-data-copy"><a class="header" href="#stack-only-data-copy">Stack-Only Data: Copy</a></h3>
<p>Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make.
In other words, there‚Äôs no difference between deep and shallow copying here, so calling clone wouldn‚Äôt do anything different from the usual shallow copying and we can leave it out.</p>
<blockquote>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on types that are stored on the stack like integers are.</p>
</blockquote>
<p>Here are some of the types that implement Copy:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>.</li>
</ul>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<p>Passing a variable to a function will <code>move</code> or <code>copy</code>, just as assignment does.
The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it.</p>
<hr />
<h2 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership rules</a></h2>
<ul>
<li>Each value in Rust has a variable that's called its <em>owner</em>.</li>
<li>There can be only one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p>This first example will fail as name has been passed to <code>Person.first_name</code>, bound to <code>p</code> and is not owned by <code>name</code> anymore.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	first_name: String,
}

fn main() {
	let name = String::from(&quot;C√©dric&quot;);
	//  ---- move occurs because `name` has type `String`,
	//       which does not implement the `Copy` trait

	let p = Person { first_name: name };
	//                            ---- value moved here

	println!(&quot;{}&quot;, name);
	//             ^^^^ value borrowed here after move
}
</code></pre></pre>
<p>It can be borrowed, though. For that you need to use references and lifetime tags.</p>
<p>The &amp; indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one
piece of data without needing to copy that data into memory multiple times. References are a complex feature, one of
Rust‚Äôs major advantages is how safe and easy it is to use references. References passed to Person&lt;'a&gt; will now be alive
as long as its usage, which is the implicit lifetime of main().</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person&lt;'a&gt; {
	first_name: &amp;'a str,
}

fn main() {
	let name = String::from(&quot;C√©dric&quot;);
	let _p = Person { first_name: &amp;name };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<p>Or simply copy or clone the value. Copy is a shallow copy, while Clone is a deep clone.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	name: String,
}

fn main() {
	let name = format!(&quot;Hello, {}!&quot;, &quot;World&quot;);
	let _p = Person { name: name.clone() };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<p>implement Copy/Clone trait</p>
<hr />
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let s1 = String::from(&quot;hello&quot;);
	let len = calculate_length(&amp;s1);
	println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
	s.len()
}
</code></pre></pre>
<p>These ampersands are <em>references</em>, and they allow you to refer to some value without taking ownership of it.</p>
<blockquote>
<p>The opposite of referencing by using <code>&amp;</code> is <em>deferencing</em>, which is accomplished with the dereference operator <code>*</code>.</p>
</blockquote>
<p>Just as variables are immutable by default, so are references. But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;mut s;
//       ------ first mutable borrow occurs here
let r2 = &amp;mut s;
//       ^^^^^^ second mutable borrow occurs here

println!(&quot;{}, {}&quot;, r1, r2);
//                 -- first borrow later used here
<span class="boring">}
</span></code></pre></pre>
<p>The benefit of having this restriction is that Rust can prevent data races at compile time. As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <em>simultaneous</em> ones.</p>
<p>A similar rule exists for combining mutable and immutable references. We also cannot have a mutable reference while we have an immutable one.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;s;
//       -- immutable borrow occurs here
let r2 = &amp;s;
let r3 = &amp;mut s;
//       ^^^^^^ mutable borrow occurs here

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
//                         -- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<h3 id="dangling-references"><a class="header" href="#dangling-references">Dangling references</a></h3>
<p>In language with pointers, it's easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that have been given to someone else or freed. In Rust, if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let ref_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
	let s = String::from(&quot;hello&quot;);

	&amp;s
}
</code></pre></pre>
<p>Because <code>s</code> is created inside <code>dangle</code>, when the code of <code>dangle</code> is finished, <code>s</code> will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid <code>String</code>.</p>
<h3 id="the-slice-type"><a class="header" href="#the-slice-type">The Slice Type</a></h3>
<p>Another data type that does not have ownership is the <em>slice</em>. Slices let you reference a continuous sequence of elements in a collection rather than the whole collection.</p>
<p>A <em>string slice</em>, for instance, is a reference to part of a <code>String</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;hello world&quot;);
let hello = &amp;s[0..5];
let world = &amp;s[6..11];
<span class="boring">}
</span></code></pre></pre>
<p>With Rust's <code>..</code> range syntax,</p>
<ul>
<li>if you want to start at the first index (zero), you can drop the trailing number: <code>[..5]</code></li>
<li>if your slice includes the last byte of the <code>String</code>, you can drop the trailing number: <code>[6..]</code></li>
<li>you can also drop both values to take a slice of the entire <code>String</code>: <code>[..]</code></li>
</ul>
<p>Recall from the borrowing rules that if we have an immutable reference to something, we cannot also take a mutable reference. In the example bellow, because <code>clear</code> needs to truncate the <code>String</code>, it tries to take a mutable reference, which fails.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let word = first_word(&amp;s)
//                    -- immutable borrow occurs here
s.clear();
//^^^^^^^ mutable borrow occurs here
println!(&quot;the first word is: {}&quot;, word);
//                                ---- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<h4 id="other-slices"><a class="header" href="#other-slices">Other Slices</a></h4>
<ul>
<li>String literals are slices</li>
<li>Arrays are a general slice type, like <code>&amp;[i32]</code></li>
</ul>
<h3 id="the-rules-of-references"><a class="header" href="#the-rules-of-references">The Rules of References</a></h3>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-enums-and-implementation"><a class="header" href="#structs-enums-and-implementation">Structs, Enums and Implementation</a></h1>
<p>There is no <code>class</code> and no inheritance. Rust has only <code>struct</code>, <code>impl</code> and <code>trait</code>.</p>
<h2 id="struct"><a class="header" href="#struct">Struct</a></h2>
<p>A <code>struct</code> is like an object's data attribute.</p>
<blockquote>
<p>It's possible for structs to store references to data owned by something else, but to do so requires the use of <em>lifetimes</em>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
	width: u32,
	height: u32,
}

let rect = Rectangle { width: 3, height: 2 };
rect.width; // =&gt; 3
<span class="boring">}
</span></code></pre></pre>
<h3 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h3>
<p>Tuple structs are useful when you want to give the whole tuple a name and make the tuple be a different type from other tuples, and naming each field as in a regular struct would be verbose or redundant.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
let black = Color(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<h3 id="unit-like-structs"><a class="header" href="#unit-like-structs">Unit-Like Structs</a></h3>
<p>You can also define structs that don't have any fields! These are called <em>unit-like structs</em> because they behave similarly to <code>()</code>, the unit type. Unit-like structs can be useful in situations in which you need to implement a trait on some type but don't have any data that you want to store in the type itself.</p>
<h2 id="method-syntax-implementation"><a class="header" href="#method-syntax-implementation">Method Syntax: Implementation</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	fn area(&amp;self) -&gt; u32 {
		self.width * self.height
	}
}

let rect = Rectangle { width: 30, height: 50 };
println!(&quot;The are is {} square pixels.&quot;, rect.area());
<span class="boring">}
</span></code></pre></pre>
<p>Methods are similar to functions. To define the function within the context of <code>Rectangle</code>, we start an <code>impl</code> block. Then we move the <code>area</code> function within the <code>impl</code> curly brackets.</p>
<p>We can use the <em>method syntax</em> to call the area method on our <code>Rectangle</code> instance.</p>
<p>In the signature for <code>area</code> we use <code>&amp;self</code> instead of <code>rectangle: &amp;Rectangle</code> because Rust knows the type of <code>self</code> is <code>Rectangle</code> due to this method's being inside the <code>impl Rectangle</code> context. Methods can take multiple parameters that we add to the signature after the <code>self</code> parameter, and those parameters work just like parameters in functions.</p>
<blockquote>
<p>Each struct is allowed to have multiple <code>impl</code> blocks.</p>
</blockquote>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated functions</a></h3>
<p>Another useful feature of <code>impl</code> blocks is that we are allowed to define functions within <code>impl</code> blocks that <em>do not</em> take <code>self</code> as a parameter. These are called <em>associated functions</em> because they are associated with the struct.</p>
<blockquote>
<p>They're still functions, not methods, because they don't have an instance of the struct to work with, like <code>String::from</code>.</p>
</blockquote>
<p>Associated functions are often used for constructors that will return a new instance of the struct. A common usage in the standard library and in the community is to define a <code>new</code> function. You can use the <em>field init shorthand</em> syntax to initialize a struct with variables.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rectangle {
	fn new(width: u32, height: u32) -&gt; Self {
		Rectangle { width, height };
	}
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="rest-and-destructuring"><a class="header" href="#rest-and-destructuring">Rest and Destructuring</a></h3>
<p>The rest operator <code>..</code> allows to fill the <em>holes</em>. It is called the <em>struct update syntax</em>.</p>
<blockquote>
<p>The rest must be the last and not be followed by a comma.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Debug)]
struct Vec2 {
	x: f32,
	y: f32
}

// Rest
let v1 = Vec2 { x: 1.0, y: 3.0 };
let v2 = Vec2 { y: 2.0, ..v1 };

// Destructuring
let (a, b) = (3, 7);

// Destructuring with Rest
let Vec2 { x,..} = v2;

println! {&quot;{:?}, {:?}, {:?}&quot;, v2, b, x} // =&gt; Vec2 { x: 1.0, y: 2.0 }, 7, 1.0
<span class="boring">}
</span></code></pre></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Rust's enums are most similar to <em>algebraic data types</em> in functional languages.
Note that the variants of the enum are namespaced (<code>::</code>) under its identifier.</p>
<p>We can put data directly into each enum variant. Each variant can have different types and amount of associated data.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
	V4(u8, u8, u8, u8),
	V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);
let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>You can put any kind of data inside an enum variant: strings, numeric types, or struct, for example. You can even include another enum.</p>
<h3 id="the-billion-dollars-mistake"><a class="header" href="#the-billion-dollars-mistake">The billion dollars mistake</a></h3>
<p>The problem with <code>null</code> values is that if you try to use a <code>null</code> value as a not-null value, you will get an error of some kind.
As such, Rust does not have nulls, but it does have an enum that can encode the concept of a value being present or absent.</p>
<p>It is replaced by the <code>Option&lt;T&gt;</code> enumeration. The variants of <code>Option</code> are <code>Some</code>
and <code>None</code>. The <code>None</code> variant represents no value while <code>Some</code> can hold one piece of data of any type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
	Some(T),
	None,
}
<span class="boring">}
</span></code></pre></pre>
<p>If we use <code>None</code> rather that <code>Some</code>, we need to tell Rust what type of <code>Option&lt;T&gt;</code> we have.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let val1: Option&lt;i32&gt; = None;
let val2: Option&lt;_&gt; = Some(32);

println!(&quot;{:?}, {:?}&quot;, val1, val2);
<span class="boring">}
</span></code></pre></pre>
<p>Because <code>Option&lt;T&gt;</code> and <code>T</code> (where <code>T</code> can be any type) are different types, the compiler won't let us use an <code>Option&lt;T&gt;</code> value as if it were definitely a valid value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
//          ^ no implementation for `i8 + Option&lt;i8&gt;`
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Everywhere that a value has a type that is not an <code>Option&lt;T&gt;</code>, you <em>can</em> safely assume that the value is not null.</p>
</blockquote>
<h3 id="error-management"><a class="header" href="#error-management">Error management</a></h3>
<p>Rust doesn't have exceptions. Instead, it has the type the type <code>Result&lt;T, E&gt;</code> for recoverable errors and the <code>panic!</code> macro that stops execution when the program encounters an unrecoverable error.</p>
<p><code>Result</code> is, like <code>Option</code>, also an enumeration. For <code>Result&lt;T, E&gt;</code>, the variants are <code>Ok&lt;T&gt;</code> and <code>Err&lt;E&gt;</code>. The <code>Ok</code> variant indicates the operation was successful, and inside <code>Ok</code> is the successfully generated value.
The <code>Err</code> variant means the operation failed, and <code>Err</code> contains information about how or why the operation failed.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::fs::File;

let f = File::open(&quot;hello.txt&quot;);
let f = match f {
	Ok(file) =&gt; file,
	Err(error) =&gt; {
		panic!(&quot;Problem opening the file: {:?}&quot;, error)
	}
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="shortcuts-for-panic-on-error-unwrap-and-expect"><a class="header" href="#shortcuts-for-panic-on-error-unwrap-and-expect">Shortcuts for Panic on Error: unwrap and expect</a></h4>
<p>Using <code>match</code> can be a bit verbose. The <code>Result&lt;T, E&gt;</code> type has many helper methods.</p>
<p>One of those method is called <code>unwrap</code>. If the <code>Result</code> value is the <code>Ok</code> variant, <code>unwrap</code> will return the value inside the <code>Ok</code>. If the <code>Result</code> is the <code>Err</code> variant, <code>unwrap</code> will call the <code>panic!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;hello.txt&quot;).unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Another method, <code>expect</code>, which is similar to <code>unwrap</code>, lets us also choose the <code>panic!</code> error message.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let f = File::open(&quot;hello.txt&quot;).expect(&quot;Failed to open hello.txt&quot;);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>It would be appropriate to call <code>unwrap</code> when you have some other logic that ensures the <code>Result</code> will have an <code>Ok</code>value, but the logic isn't something the compiler understands.</p>
</blockquote>
<h4 id="propagating-errors"><a class="header" href="#propagating-errors">Propagating Errors</a></h4>
<p>This pattern of propagating errors is so common in Rust that Rust provides the question mark operator <code>?</code> to make this easier. Error values that have the <code>?</code> operator called on them go through the <code>from</code> function, defined in the <code>From</code> trait in the standard library, which is used to convert errors from one type into another.</p>
<p>the <code>?</code> operator eliminates a lot of boilerplate and makes this function's implementation simpler. We could event shorten the code further by chaining method calls immediately after the <code>?</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn read_username_from_file() -&gt; Result&lt;String, io::error&gt; {
	let mut s = String::new();
	File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;
	Ok(s);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The <code>?</code> operator can only be used in functions that have a return type of <code>Result</code>.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2021">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
	let f = File::open(&quot;hello.txt&quot;)?;

	Ok(());
}
</code></pre></pre>
<p>The <code>Box&lt;dyn Error&gt;</code> type is called a trait object. For now, you can read <code>Box&lt;dyn Error&gt;</code> to mean &quot;any kind of error&quot;.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-types-traits-and-lifetimes"><a class="header" href="#generic-types-traits-and-lifetimes">Generic Types, Traits and Lifetimes</a></h1>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics are abstract stand-ins for concrete types or other properties.</p>
<p>We can use generics to create definitions for items like function signatures or structs, which we can then use with many different concrete data types.</p>
<p>To define the generic <code>largest</code> function, place type name declaration inside angle brackets, <code>&lt;&gt;</code>, between the name of the function and the parameter list.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {}
<span class="boring">}
</span></code></pre></pre>
<p>We can also define structs to use a generic type parameter in one or more fields using the <code>&lt;&gt;</code> syntax.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
	x: T,
	y: T,
}
<span class="boring">}
</span></code></pre></pre>
<p>To define a <code>Point</code> struct where <code>x</code> and <code>y</code> are both generics but could have different types, we can use multiple generic type parameters.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T, U&gt; {
	x: T,
	y: U,
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>You can use as many generic type parameters in a definition as you want, but using more than a few makes your code hard to read.</p>
</blockquote>
<p>We can define enums to hold generic data types in their variants as we just see in <code>Option&lt;T&gt;</code> that returns <code>Some&lt;T&gt;</code> for instance.</p>
<p>We can also implement methods on structs and enums and use generic types in their definitions, too.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T&gt; {
	x: T,
	y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
	fn x(&amp;self) -&gt; &amp;T {
		&amp;self.x
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Note that we have to declare <code>T</code> just after <code>impl</code> so we can use it to specify that we are implementing methods on the type <code>Point&lt;T&gt;</code>. By declaring <code>T</code> as a generic type after <code>impl</code>, Rust can identify that the type in the angle brackets in <code>Point</code> is a generic type rather than a concrete type.</p>
<p>We could, for example, implement methods only on <code>Point&lt;f32&gt;</code> instances rather than on <code>Point&lt;T&gt;</code> instances with a generic type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Point&lt;f32&gt; {
	fn distance_form_origin(&amp;self) -&gt; f32 {
		(self.x.powi(2) + self.y.powi(2)).sqrt()
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>Generic type parameters in a struct definition aren't always the same as those you use in that struct`s method signatures.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Point&lt;T, U&gt; {
	x: T,
	y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
	fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
		Point {
			x: self.x
			y: other.y
		}
	}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust implements generics by performing monomorphization of the code that is using generics at compile time. <em>Monomorphization</em> is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. With that, there is no runtime cost.</p>
</blockquote>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p>Trait definitions are a way to group method signatures together to define a set of behaviours necessary to accomplish some purpose. They are some kind of <em>interfaces</em>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">trait Geometry {
	fn area(&amp;self) -&gt; u32;
}

struct Rectangle {
	width: u32,
	height: u32,
}

impl Rectangle {
	// Common Rust way to do a &quot;constructor&quot;
	fn new(width: u32, height: u32) -&gt; Self {
		Self { width, height }
	}
}

impl Geometry for Rectangle {
	fn area(&amp;self) -&gt; u32 {
		self.width * self.height
	}
}

fn main() {
	let rect = Rectangle::new(20, 30);

	println!(
		&quot;The area of the rectangle is {} square pixels.&quot;,
		rect.area()
	);
}
</code></pre></pre>
<p>The difference is that after <code>impl</code>, we put the trait name that we want to implement, then use the <code>for</code>keyword, and then specify the name of the type we want to implement the trait for. Within the <code>impl</code> block, we put the method signatures that the trait definition has defined.</p>
<hr />
<p>The <code>::</code> syntax in the <code>::new</code> line indicates that new is an associated function of the <code>Rectangle</code> type. An associated
function is implemented on a type, rather than on a particular instance of a <code>Rectangle</code>. Some language call this a _
static method_.</p>
<blockquote>
<p>You will find a new function on many types, even in the standard library, because it's a common name for a function
that makes a new value of some kind.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="if-expressions"><a class="header" href="#if-expressions"><code>if</code> Expressions</a></h3>
<p>Blocks of code associated with the conditions in <code>if</code> expressions are sometimes called <em>arms</em>, just like the arm in <code>match</code> expressions. Optionally, we can also include an <code>else</code> expression (or <code>else if</code>). It's also worth noting that the condition <em>must</em> be a <code>bool</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn eight() -&gt; i32 {
	if true {
		8
	} else {
		4
	}
}

println!(&quot;{}&quot;, eight()); // =&gt; 8
<span class="boring">}
</span></code></pre></pre>
<h4 id="using-if-in-a-let-statement"><a class="header" href="#using-if-in-a-let-statement">Using <code>if</code> in a <code>let</code> statement</a></h4>
<p>Because <code>if</code> is an expression, we can use it on the right side of a <code>let</code> statement. Remember that blocks of code evaluate to the last expression in them. This means the values that have the potential to be results from each arm of the <code>if</code> must be the <strong>same type</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = true;
let number = if condition {
	5
} else {
	6
};

println!(number is &quot;{}&quot;, number);
<span class="boring">}
</span></code></pre></pre>
<h3 id="repetitions"><a class="header" href="#repetitions">Repetitions</a></h3>
<p>Rust has three kinds of loops: <code>loop</code>, <code>while</code> and <code>for</code>.</p>
<h4 id="loops"><a class="header" href="#loops">Loops</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>loop {
	println!(&quot;again!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>You might need to pass the result of a <code>loop</code>. To do this, add the value you want returned after the <code>break</code> expression, you use to stop the loop.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut counter = 0;

let result = loop {
	counter += 1;

	if counter == 10 {
		break counter * 2;
	}
};
<span class="boring">}
</span></code></pre></pre>
<h4 id="conditional-loops-with-while"><a class="header" href="#conditional-loops-with-while">Conditional Loops with <code>while</code></a></h4>
<p>It's often useful for a program to evaluate a condition within a loop. While the condition is true, the loop runs.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut number = 3;

while number != 0 {
	number = number - 1;
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="looping-through-a-collection-with-for"><a class="header" href="#looping-through-a-collection-with-for">Looping Through a Collection with <code>for</code></a></h3>
<p>You can use a <code>for</code> loop and execute some code for each item in a collection. The safety and consiceness of <code>for</code> loops make them the most commonly used loop construct in Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for number in (1..4).rev() {
	println(&quot;{}!&quot;, number);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><code>.rev()</code> reverses the range</p>
</blockquote>
<h2 id="the-match-control-flow-operator"><a class="header" href="#the-match-control-flow-operator">The match Control Flow Operator</a></h2>
<p>Rust has an extremely powerful control flow operator called <code>match</code> that allows you to compare a value against a series of patterns and then execute code based on which pattern matches. The power of <code>match</code> comes from the expressiveness of the patterns and the fact that the compiler confirms that all possible cases are handled.</p>
<blockquote>
<p>When the <code>match</code> expression executes, it compares the resulting value against the pattern of each arm, in order.</p>
</blockquote>
<p>The code associated with each arm is an expression, and the resulting value of the expression in the matching arm is the value that gets returned for the entire <code>match</code> expression.</p>
<blockquote>
<p>Curly brackets typically are not used if the match arm code is short.</p>
</blockquote>
<p>Another useful feature of match arms is that they can bind to the parts of the values that match the pattern. This is how we can extract values out of enum variants.</p>
<p>Combining <code>match</code> and enums is useful in many situation. You will see this pattern a lot in Rust code: match against an enum, bind a variable to the data inside, and then execute code based on it.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Number {
	odd: bool,
	value: i32,
}

let one = Number { odd: true, value: 1 };
let two = Number { odd: false, value: 2 };

print_number(one); // =&gt; Odd number: 1
print_number(two); // =&gt; Even number: 2

// Same as with the if pattern
fn print_number(n: Number) {
	match n {
		Number { odd: true, value } =&gt; println!(&quot;Odd number: {}&quot;, value),
		Number { odd: false, value } =&gt; println!(&quot;Even number: {}&quot;, value),
	}
}
<span class="boring">}
</span></code></pre></pre>
<p>A <code>match</code> has to be exhaustive. At least one arm needs to match.
<code>_</code> can be used as a &quot;catch-all&quot; special pattern that will match any value if we do not want to list all possible values.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print_number(n: Number) {
	match n.value {
		1 =&gt; println!(&quot;One&quot;),
		2 =&gt; println!(&quot;Two&quot;),
		_ =&gt; (),
	}
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The <code>()</code> is just the unit value, so nothing will happen in the <code>_</code> case here.</p>
</blockquote>
<h2 id="concise-control-flow-with-if-let"><a class="header" href="#concise-control-flow-with-if-let">Concise Control Flow with if let</a></h2>
<p>The <code>if let</code> syntax lets you combine <code>if</code> and <code>let</code> into a less verbose way to handle values that match one pattern while ignoring the rest.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = Some(40);
let b = None;

print_number(a); // =&gt; 40
print_number(b); // =&gt; No output

fn print_number(n: Option&lt;i32&gt;) {
	if let Some(value) = n {
		println!(&quot;{}&quot;, value)
	}
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>Unlike the built-in array and tuple types, the data these collections point to is stored on the heap, which means the amount of data does not need to be known at compile time.</p>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p>Vectors <code>Vec&lt;T&gt;</code> allow you to store more than on value in a single data structure that puts all the values next to each other in memory. Vectors can only store values of the same type <code>T</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
v.push(1);
// ...
// or
let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Rust provides the <code>vec!</code>macro for convenience.</p>
</blockquote>
<h3 id="reading-elements-of-vectors"><a class="header" href="#reading-elements-of-vectors">Reading Elements of Vectors</a></h3>
<p>There are two ways to reference a value stored in a vector.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];

match v.get(2) {
    Some(third) =&gt; println!(&quot;The third element is: {}.&quot;, third);
    None =&gt; println!(&quot;There is no third element.&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The first <code>[]</code> method may cause the program to panic if it references a nonexistent element, like <code>&amp;v[100]</code>.
When the <code>get</code> method is passed an index that is outside the vector, it returns <code>None</code> without panicking.</p>
</blockquote>
<p>When the program has a valid reference, the borrow checker enforces the ownership and borrowing rules to ensure this reference and any other references to the contents of the vector remain valid.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let first = &amp;v[0];
//           - immutable borrow occurs here
v.push(6);
//^^^^^^^ mutable borrow occurs here
println!(&quot;The first element is: {}&quot;, first);
//                                   ----- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<p>This error is due to the way vectors work: adding a new element onto the end of the vector might require allocating new memory and copying the old elements to the new space. In that case, the reference to the first element would be pointing to deallocated memory.</p>
<h3 id="iterating-over-the-values-in-a-vector"><a class="header" href="#iterating-over-the-values-in-a-vector">Iterating over the Values in a Vector</a></h3>
<p>If we want to access each element in a vector in turn, we can iterate through all of the elements rather than use indices to access one at a time.</p>
<p>We can also iterate over mutable references to each element in a mutable vector in order to make changes to all the elements.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>To change the value that the mutable reference refers to, we have to use the dereference operator <code>*</code> to get to the value in <code>i</code> before we can use the <code>+=</code> operator.</p>
</blockquote>
<h3 id="using-an-enum-to-store-multiple-types"><a class="header" href="#using-an-enum-to-store-multiple-types">Using an Enum to Store Multiple Types</a></h3>
<p>We said that vectors can only store values that are the same type. Fortunately, the variant of an enum are defined under the same enum type, so when we need to store elements of a different type in vector, we can defined and use an enum.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blue&quot;)),
    SpreadsheetCell:: Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<h2 id="storing-utf-8-encoded-text-with-strings"><a class="header" href="#storing-utf-8-encoded-text-with-strings">Storing UTF-8 Encoded Text with Strings</a></h2>
<p>Rust has only one string type in the core language, which is the string slice <code>str</code> that is usually seen in its borrowed form <code>&amp;str</code>.</p>
<p>The <code>String</code> type, which is provided by Rust`s standard library rather than coded into the core language, is a growable, mutable, owned, UTF-8 encoded string type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
s.push_str(&quot;hello&quot;);
let h = s[0];
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s1 = String::from(&quot;tac&quot;);
let s1 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3; // note s1 has been moved here
let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>A <code>String</code> is a wrapper over a <code>Vec&lt;u8&gt;</code>.</p>
</blockquote>
<p>In UTF-8, each Unicode scalar value may takes more than one byte of storage. Think of Cyrillic, Japanese or Hindi signs. Therefore, an index into the string's bytes will not always correlate to a valid Unicode scalar value.</p>
<p>Another point about UTF-8 is that there are actually three relevant ways to look at strings from Rust's perspective: as bytes, scalar values, and grapheme clusters (the closest thing to what we would call <em>letters</em>).</p>
<p>Sometimes when you extract chars from a string, you will have diacritics that do not make sense on their own. So, indexing into a string is often a bad idea because it is not clear what the return type of the string-indexing operation should be: a byte value, a character, a grapheme cluster, or a string slice.</p>
<p>Getting grapheme clusters from strings is complex, so this functionality is not provided by the standard library. You can check the <a href="https://crates.io/crates/unicode-segmentation"><code>unicode-segmentation</code></a> crate.</p>
<blockquote>
<p>Rust has chosen to make the correct handling of <code>String</code> data the default behaviour for all Rust programs, which means programmers have to put more thought into handling UTF-8 data up front. This trade-off exposes more of the complexity of strings than is apparent in other programming languages, but it prevents you from having to handle errors involving non-ASCII characters later in your development life cycle</p>
</blockquote>
<h2 id="hash-maps"><a class="header" href="#hash-maps">Hash Maps</a></h2>
<p>The type <code>HashMap&lt;K, V&gt;</code> stores a mapping of keys of type <code>K</code> to values of type <code>V</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blue&quot;), 10);
scores.insert(String::from(&quot;Yellow&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Of our three common collections, this one is the least often used, so it is not included in the features brought into scope automatically in the prelude.</p>
</blockquote>
<p>Another way of constructing a hash map is by using the <code>collect</code> method on a vector of tuples, where each tuple consists of a key and its value.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let map = vec![(String::from(&quot;Blue&quot;), 10), (String::from(&quot;Yellow&quot;), 50)].collect();
<span class="boring">}
</span></code></pre></pre>
<p>We could also use the <code>zip</code> method to create a vector of tuples.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams = vec![String::from(&quot;Blue&quot;), String::from(&quot;Yellow&quot;)];
let initial_scores = vec![10, 50];

let scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>For types that implements the <code>Copy</code>trait, such as <code>i32</code>, the values are copied into the hash map. For owned values such as <code>String</code>, the values will be moved and the hash map will be the owner of those values.</p>
</blockquote>
<h3 id="accessing-values"><a class="header" href="#accessing-values">Accessing Values</a></h3>
<p>We can get a value out of the hash map by proving its key to the <code>get</code> method. The result is wrapped in <code>Some</code> because <code>get</code> returns an <code>Option&lt;&amp;V&gt;</code>.</p>
<p>We can iterates over each key/value pair in a similar manner as we do with vectors, using a <code>for</code> loop.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="updating-a-hash-map"><a class="header" href="#updating-a-hash-map">Updating a Hash Map</a></h2>
<blockquote>
<p>Each key can only have on value associated with it at a time.</p>
</blockquote>
<p>If we insert a key and a value into a hash map and then insert that same key with a different value, the value associated with that key will be replaced.</p>
<p>Hash Maps have a special API for inserting a value only if the key has no value, called <code>entry</code>. It takes the key you want to check as a parameter. The return value of the entry method is an enum called <code>Entry</code> that represents a value that might or might not exist.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blue&quot;), 10);

scores.entry(String::from(&quot;Yellow&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blue&quot;)).or_insert(50);
<span class="boring">}
</span></code></pre></pre>
<p>The <code>or_insert</code> method on <code>Entry</code> is defined to return a mutable reference to the value for the corresponding <code>Entry</code> key if that exists, and if not, inserts the parameter as the new value for this key and returns a mutable reference (<code>&amp;mut V</code>) to the new value.</p>
<blockquote>
<p>By default, <code>HashMap</code> uses a cryptographically strong hashing function that is not the fastest algorithm available. You can switch to another function by specifying a different <em>hasher</em>. A hasher is a type that implements the <code>BuildHasher</code>trait.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates-and-modules"><a class="header" href="#crates-and-modules">Crates and Modules</a></h1>
<p>Rust has a specific way of declaring things.</p>
<p>By default, Rust brings only a few types into the scope of every program in the prelude. If a type you want to use is
not in the prelude, you have to bring that type into scope explicitly with a <code>use</code> statement.</p>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>The double colon <code>::</code> is an operator that allows us to namespace this particular <code>from</code> function under the <code>String</code> type.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>String::from(&quot;Hey&quot;);
```

## Crate

A crate may contains a lot of modules. A crate is a folder where, in its root, you have a `Cargo.toml` file.

&gt; You can compare it to package.json in the JavaScript world, although we used to call it a node module. You import it
&gt; with a single name, the node module name.

## Modules

- A module is a file.
- Or a folder with a mod.rs file inside.

&gt; In the JavaScript world this is a module, or an ES module. This is when you import a file with a relative path instead
&gt; of a name.

## Functions

Every module exports functions.

# Usage

```rust
use std::cmp::min(3, 8); // =&gt; 3
use std::cmp::*
<span class="boring">}
</span></code></pre></pre>
<p>The JavaScript equivalent would be, considering that the folder <code>cmp</code> contains an <code>index.js</code> file.</p>
<pre><code class="language-javascript">import { min } from &quot;std/cmp&quot;;
import { * as cmp } from &quot;std/cmp&quot;;

// or inside &quot;std&quot;
import { min } from &quot;./cmp&quot;;
</code></pre>
<h3 id="types-are-namespace-too"><a class="header" href="#types-are-namespace-too">Types are namespace too</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = &quot;rust&quot;.len(); // =&gt; 4
let x = str::len(&quot;rust&quot;); // =&gt; 4
<span class="boring">}
</span></code></pre></pre>
<h2 id="prelude"><a class="header" href="#prelude">Prelude</a></h2>
<p>Rust inserts this at the beginning of every module.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::prelude::v1::*;
<span class="boring">}
</span></code></pre></pre>
<p>So that, instead of <code>std::vec::Vec::new()</code>, you can use <code>Vec::new()</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="useful-crates"><a class="header" href="#useful-crates">Useful Crates</a></h1>
<p>This list is obviously very <strong>opiniated</strong> and <strong>not complete</strong>. It's a list a useful crates I discovered while using
Rust. Some better-known crates are not displayed below, because I prefer the ones listed here.</p>
<h2 id="general-purpose"><a class="header" href="#general-purpose">General purpose</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/futures">futures</a></td><td>Futures and streams featuring zero allocations, composability, and iterator-like interfaces.</td></tr>
<tr><td><a href="https://crates.io/crates/itertools">itertools</a></td><td>Extra iterator adaptors, iterator methods, free functions, and macros.</td></tr>
<tr><td><a href="https://crates.io/crates/lazy_static">lazy_static</a></td><td>A macro for declaring lazily evaluated statics in Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/rayon">rayon</a></td><td>Simple work-stealing parallelism for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/serde">serde</a></td><td>A generic serialization/deserialization framework.</td></tr>
<tr><td><a href="https://crates.io/crates/serde_json">serde_json</a></td><td>A JSON serialization file format.</td></tr>
<tr><td><a href="https://crates.io/crates/tokio">tokio</a></td><td>An event-driven, non-blocking I/O platform for writing asynchronous I/O backed applications.</td></tr>
</tbody></table>
<h2 id="math-physics-geo-bio"><a class="header" href="#math-physics-geo-bio">Math, Physics, Geo, Bio</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/bio">bio</a></td><td>A bioinformatics library for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/geo">geo</a></td><td>Geospatial primitives and algorithms.</td></tr>
<tr><td><a href="https://crates.io/crates/nalgebra">nalgebra</a></td><td>General-purpose linear algebra library with transformations and statically-sized or dynamically-sized matrices. <a href="https://dimforge.com">Dimforge</a></td></tr>
<tr><td><a href="https://crates.io/crates/num">num</a></td><td>A collection of numeric types and traits (bigint, complex, rational, range iterators, generic integers...)</td></tr>
<tr><td><a href="https://crates.io/crates/parry2d">parry2d</a></td><td>2 dimensional collision detection library in Rust. <a href="https://dimforge.com">Dimforge</a></td></tr>
<tr><td><a href="https://crates.io/crates/rand">rand</a></td><td>Random number generators and other randomness functionality.</td></tr>
</tbody></table>
<h2 id="string-encoding-time-and-crypto"><a class="header" href="#string-encoding-time-and-crypto">String, Encoding, Time and Crypto</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/chrono">chrono</a></td><td>Date and time library for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/crypto">crypto</a></td><td>Resources for building cryptosystems in Rust using the RustCrypto project's ecosystem.</td></tr>
<tr><td><a href="https://crates.io/crates/data-encoding">data-encoding</a></td><td>Data-encoding functions like base64, base32, and hex.</td></tr>
<tr><td><a href="https://crates.io/crates/fluent">fluent</a></td><td>A localization system designed to unleash the entire expressive power of natural language translations.</td></tr>
<tr><td><a href="https://crates.io/crates/regex">regex</a></td><td>An implementation of regular expressions for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/unicode-segmentation">unicode-segmentation</a></td><td>Grapheme Cluster, Word and Sentence boundaries according to Unicode Standard Annex #29 rules.</td></tr>
<tr><td><a href="https://crates.io/crates/uuid">uuid</a></td><td>A library to generate and parse UUIDs.</td></tr>
</tbody></table>
<h2 id="files"><a class="header" href="#files">Files</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/dotenvy">dotenvy</a></td><td>A <code>dotenv</code> implementation for Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/roxmltree">roxmltree</a></td><td>Represent an XML as a read-only tree.</td></tr>
<tr><td><a href="https://crates.io/cratess/ron">ron</a></td><td>Rusty Object Notation</td></tr>
<tr><td><a href="https://crates.io/crates/toml">toml</a></td><td>A native Rust encoder and decoder of TOML-formatted files and streams.</td></tr>
</tbody></table>
<h2 id="cli"><a class="header" href="#cli">CLI</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://github.com/clap-rs/clap">clap</a></td><td>Command Line Argument Parser for Rust.</td></tr>
<tr><td><a href="https://github.com/mitsuhiko/console">console</a></td><td>A Rust console and terminal abstraction.</td></tr>
<tr><td><a href="https://github.com/rust-lang/log">log</a></td><td>A Rust library providing a lightweight logging facade.</td></tr>
</tbody></table>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/slab">slab</a></td><td>Pre-allocated storage for a uniform data type.</td></tr>
<tr><td><a href="https://crates.io/crates/sqlx">sqlx</a></td><td>An async SQL crate. Supports PostgreSQL, MySQL, and SQLite.</td></tr>
</tbody></table>
<h2 id="graphics-and-ui"><a class="header" href="#graphics-and-ui">Graphics and UI</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/image">image</a></td><td>Imaging library written in Rust. Provides basic filters and decoders for the most common image formats.</td></tr>
<tr><td><a href="https://crates.io/crates/piet">piet</a></td><td>An abstraction for 2D graphics.</td></tr>
<tr><td><a href="https://crates.io/crates/piet-svg">piet-svg</a></td><td>SVG backend for piet 2D graphics abstraction.</td></tr>
</tbody></table>
<h2 id="web"><a class="header" href="#web">Web</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/async-graphql">async-graphql</a></td><td>A GraphQL server library implemented in Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/axum">axum</a></td><td>Web framework that focuses on ergonomics and modularity.</td></tr>
<tr><td><a href="https://crates.io/crates/hyper">hyper</a></td><td>A fast and correct HTTP library.</td></tr>
<tr><td><a href="https://crates.io/crates/jsonwebtoken">jsonwebtoken</a></td><td>Create and decode JWTs in a strongly typed way.</td></tr>
<tr><td><a href="https://crates.io/crates/lettre">lettre</a></td><td>Email client</td></tr>
<tr><td><a href="https://crates.io/crates/reqwest">reqwest</a></td><td>Higher level HTTP client library.</td></tr>
<tr><td><a href="https://crates.io/crates/tower">tower</a></td><td>Tower is a library of modular and reusable components for building robust clients and servers.</td></tr>
<tr><td><a href="https://crates.io/crates/tower-http">tower-http</a></td><td>Tower middleware and utilities for HTTP clients and servers.</td></tr>
<tr><td><a href="https://crates.io/crates/async-tungstenite">tungstenite</a></td><td>Async binding for Tungstenite, the Lightweight stream-based WebSocket implementation.</td></tr>
</tbody></table>
<h2 id="webassembly"><a class="header" href="#webassembly">WebAssembly</a></h2>
<table><thead><tr><th>Crate Name</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="https://crates.io/crates/console_error_panic_hook">console_error_panic_hook</a></td><td>A panic hook for <code>wasm32-unknown-unknown</code> that logs panics to <code>console.error</code>.</td></tr>
<tr><td><a href="https://crates.io/crates/js-sys">js-sys</a></td><td>Bindings for all JS global objects and functions in all JS environments.</td></tr>
<tr><td><a href="https://crates.io/crates/piet-web">piet-web</a></td><td>Web canvas backend for piet 2D graphics abstraction.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen">wasm-bindgen</a></td><td>Easy support for interacting between JS and Rust.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen-futures">wasm-bindgen-futures</a></td><td>Bridging the gap between Rust Futures and JavaScript Promises.</td></tr>
<tr><td><a href="https://crates.io/crates/wasm-bindgen-rayon">wasm-bindgen-rayon</a></td><td>Adapter for using Rayon-based concurrency on the Web.</td></tr>
<tr><td><a href="https://crates.io/crates/web-sys">web-sys</a></td><td>Bindings for all Web APIs.</td></tr>
<tr><td><a href="https://crates.io/crates/wee_alloc">wee_alloc</a></td><td>The Wasm-Enabled, Elfin Allocator.</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
