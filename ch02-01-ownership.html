<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ownership, Borrowing and Lifetime - Concise Rust &amp; WebAssembly</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="ch00-01-title-page.html">Concise Rust and WebAssembly</a></li><li class="chapter-item expanded affix "><a href="ch00-02-foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="ch00-03-rust.html">The Rust Programming Language</a></li><li class="chapter-item expanded "><a href="ch01-00-basics.html"><strong aria-hidden="true">1.</strong> The Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-variables.html"><strong aria-hidden="true">1.1.</strong> Variables and Data types</a></li><li class="chapter-item expanded "><a href="ch01-02-block-scope.html"><strong aria-hidden="true">1.2.</strong> Functions, Blocks and Scope</a></li><li class="chapter-item expanded "><a href="ch01-03-patterns.html"><strong aria-hidden="true">1.3.</strong> Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-particularities.html"><strong aria-hidden="true">2.</strong> Particularities</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch02-01-ownership.html" class="active"><strong aria-hidden="true">2.1.</strong> Ownership, Borrowing and Lifetime</a></li><li class="chapter-item expanded "><a href="ch02-02-option-result.html"><strong aria-hidden="true">2.2.</strong> Option and Result</a></li><li class="chapter-item expanded "><a href="ch02-03-struct-trait.html"><strong aria-hidden="true">2.3.</strong> Struct, Implementation and Traits</a></li><li class="chapter-item expanded "><a href="ch02-04-unsafe.html"><strong aria-hidden="true">2.4.</strong> Unsafe</a></li></ol></li><li class="chapter-item expanded "><a href="ch03-00-crates-modules.html"><strong aria-hidden="true">3.</strong> Crates and Modules</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> WebAssembly</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> WASI &amp; Wasmtime</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Cargo</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> wasm-pack</div></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-useful-crates.html"><strong aria-hidden="true">6.</strong> Useful Crates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Concise Rust &amp; WebAssembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/cedeber/concise-rust-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ownership-borrowing-and-lifetime"><a class="header" href="#ownership-borrowing-and-lifetime">Ownership, Borrowing and Lifetime</a></h1>
<p>Ownership is the most unique feature of Rust, and it enables Rust to make memory safety guarantees without needing a garbage collector.</p>
<blockquote>
<p>Don’t try to fight against the borrow checker.</p>
</blockquote>
<h2 id="the-stack-and-the-heap"><a class="header" href="#the-stack-and-the-heap">The Stack and the Heap</a></h2>
<p>The <em>stack</em> stores values in the order it gets them and removes the values in the opposite order. This is referred to as <em>last in, first out</em>. All data stored in the stack must have a known, fixed size. Data with an unknown size at compile time or a size that might change must be stored on the heap instead.</p>
<p>The <em>heap</em> is less organized. The operating system finds an empty spot in the heap that is big enough, marks it as being in use, and returns a pointer, which is the address of that location. This process is called allocating on the heap.</p>
<p>Pushing to the stack is faster than allocating on the heap because the operating system never has to search for a place to store new data. Comparatively, allocating space on the heap requires more work, because the operating system must first find a big enough space to hold the data and then perform bookkeeping to prepare for the next allocation.</p>
<p>Accessing data in the heap is slower than accessing data on the stack because you have to follow a pointer to get there. Contemporary processors are faster if they jump around less in memory.</p>
<h2 id="memory-and-allocation"><a class="header" href="#memory-and-allocation">Memory and Allocation</a></h2>
<p>In the case of a string literal, we know the content at compile time, so the text is hardcoded directly into the final executable. This is why string literals are fast and efficient.</p>
<p>With the <code>String</code> type, in order to support a mutable, growable piece of text, we need to allocate an amount of memory on the heap, unknown at compile time, to hold the content.</p>
<p>When a variable goes out of scope, Rust calls a special function for us. This function is called <code>drop</code>. Rust call <code>drop</code> automatically at the closing curly bracket.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut s = String::From(&quot;hello&quot;);
s.push_str(&quot;, world!&quot;); // appends a literal to a String
println!(&quot;{}&quot;, s);
<span class="boring">}
</span></code></pre></pre>
<h3 id="move"><a class="header" href="#move">Move</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>bind the value 5 to <code>x</code>; then make a <strong>copy</strong> of the value in <code>x</code> and bind it to <code>y</code>.</p>
</blockquote>
<p>This is indeed what is happening, because integers are simple values with a known, fixed size and these two 5 values are pushed on the <strong>stack</strong>.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>A <code>String</code> is made of three parts: a <em>pointer</em> to the memory that holds the content of the string, a <em>length</em>, and a <em>capacity</em>.</p>
<div style="display: flex; gap: 40px; justify-content: center;">
<div>
<p style="text-align: center;">s1</p>
<table><thead><tr><th>name</th><th>value</th></tr></thead><tbody>
<tr><td>ptr</td><td>→</td></tr>
<tr><td>len</td><td>5</td></tr>
<tr><td>capacity</td><td>5</td></tr>
</tbody></table>
</div>
<div>
<p style="text-align: center;">data</p>
<table><thead><tr><th>index</th><th>value</th></tr></thead><tbody>
<tr><td>0</td><td>h</td></tr>
<tr><td>1</td><td>e</td></tr>
<tr><td>2</td><td>l</td></tr>
<tr><td>3</td><td>l</td></tr>
<tr><td>4</td><td>o</td></tr>
</tbody></table>
</div>
</div>
<p>When we assign <code>s1</code> to <code>s2</code>, the <code>String</code> data is copied, meaning we copy the pointer, the length, and the capacity that are on the <strong>stack</strong>.
<em>We do not copy the data on the heap that the pointer refers to</em>.</p>
<p>Again, when a variable goes out of scope, Rust automatically calls the <code>drop</code> function and cleans up the heap memory for that variable.
When s2 and s1 go out of scope, they will both try to free the same memory. This is known as a <em>double free</em> error and is one of the memory safety bugs.</p>
<p>Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and, therefore, Rust doesn't need to free anything when s1 goes out of scope.</p>
<p>If you’ve heard the terms <em>shallow copy</em> and <em>deep copy</em> while working with other languages, the concept of copying the pointer, length, and capacity without copying the data probably sounds like making a shallow copy. But because Rust also invalidates the first variable, instead of calling it a shallow copy, it’s known as a <em>move</em>.</p>
<blockquote>
<p>Rust will never automatically create “deep” copies of your data. Therefore, any <em>automatic</em> copying can be assumed to be inexpensive in terms of runtime performance.</p>
</blockquote>
<h3 id="clone"><a class="header" href="#clone">Clone</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;hello&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>When you see a call to <code>clone</code>, you know that some arbitrary code is being executed and that code may be expensive. It’s a visual indicator that something different is going on.</p>
<h3 id="stack-only-data-copy"><a class="header" href="#stack-only-data-copy">Stack-Only Data: Copy</a></h3>
<p>Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make.
In other words, there’s no difference between deep and shallow copying here, so calling clone wouldn’t do anything different from the usual shallow copying and we can leave it out.</p>
<blockquote>
<p>Rust has a special annotation called the <code>Copy</code> trait that we can place on types that are stored on the stack like integers are.</p>
</blockquote>
<p>Here are some of the types that implement Copy:</p>
<ul>
<li>All the integer types, such as <code>u32</code>.</li>
<li>The Boolean type, <code>bool</code>, with values <code>true</code> and <code>false</code>.</li>
<li>All the floating point types, such as <code>f64</code>.</li>
<li>The character type, <code>char</code>.</li>
<li>Tuples, if they only contain types that also implement <code>Copy</code>.</li>
</ul>
<h3 id="ownership-and-functions"><a class="header" href="#ownership-and-functions">Ownership and Functions</a></h3>
<p>Passing a variable to a function will <code>move</code> or <code>copy</code>, just as assignment does.
The ownership of a variable follows the same pattern every time: assigning a value to another variable moves it.</p>
<hr />
<h2 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership rules</a></h2>
<ul>
<li>Each value in Rust has a variable that's called its <em>owner</em>.</li>
<li>There can be only one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped.</li>
</ul>
<p>This first example will fail as name has been passed to <code>Person.first_name</code>, bound to <code>p</code> and is not owned by <code>name</code> anymore.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	first_name: String,
}

fn main() {
	let name = String::from(&quot;Cédric&quot;);
	//  ---- move occurs because `name` has type `String`,
	//       which does not implement the `Copy` trait

	let p = Person { first_name: name };
	//                            ---- value moved here

	println!(&quot;{}&quot;, name);
	//             ^^^^ value borrowed here after move
}
</code></pre></pre>
<p>It can be borrowed, though. For that you need to use references and lifetime tags.</p>
<p>The &amp; indicates that this argument is a reference, which gives you a way to let multiple parts of your code access one
piece of data without needing to copy that data into memory multiple times. References are a complex feature, one of
Rust’s major advantages is how safe and easy it is to use references. References passed to Person&lt;'a&gt; will now be alive
as long as its usage, which is the implicit lifetime of main().</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person&lt;'a&gt; {
	first_name: &amp;'a str,
}

fn main() {
	let name = String::from(&quot;Cédric&quot;);
	let _p = Person { first_name: &amp;name };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<p>Or simply copy or clone the value. Copy is a shallow copy, while Clone is a deep clone.</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Person {
	name: String,
}

fn main() {
	let name = format!(&quot;Hello, {}!&quot;, &quot;World&quot;);
	let _p = Person { name: name.clone() };

	println!(&quot;{}&quot;, name);
}
</code></pre></pre>
<p>implement Copy/Clone trait</p>
<hr />
<h2 id="references-and-borrowing"><a class="header" href="#references-and-borrowing">References and Borrowing</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let s1 = String::from(&quot;hello&quot;);
	let len = calculate_length(&amp;s1);
	println!(&quot;The length of '{}' is {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
	s.len()
}
</code></pre></pre>
<p>These ampersands are <em>references</em>, and they allow you to refer to some value without taking ownership of it.</p>
<blockquote>
<p>The opposite of referencing by using <code>&amp;</code> is <em>deferencing</em>, which is accomplished with the dereference operator <code>*</code>.</p>
</blockquote>
<p>Just as variables are immutable by default, so are references. But mutable references have one big restriction: you can have only one mutable reference to a particular piece of data in a particular scope.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;mut s;
//       ------ first mutable borrow occurs here
let r2 = &amp;mut s;
//       ^^^^^^ second mutable borrow occurs here

println!(&quot;{}, {}&quot;, r1, r2);
//                 -- first borrow later used here
<span class="boring">}
</span></code></pre></pre>
<p>The benefit of having this restriction is that Rust can prevent data races at compile time. As always, we can use curly brackets to create a new scope, allowing for multiple mutable references, just not <em>simultaneous</em> ones.</p>
<p>A similar rule exists for combining mutable and immutable references. We also cannot have a mutable reference while we have an immutable one.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let r1 = &amp;s;
//       -- immutable borrow occurs here
let r2 = &amp;s;
let r3 = &amp;mut s;
//       ^^^^^^ mutable borrow occurs here

println!(&quot;{}, {}, and {}&quot;, r1, r2, r3);
//                         -- immutable borrow later used here
<span class="boring">}
</span></code></pre></pre>
<h3 id="dangling-references"><a class="header" href="#dangling-references">Dangling references</a></h3>
<p>In language with pointers, it's easy to erroneously create a <em>dangling pointer</em>, a pointer that references a location in memory that have been given to someone else or freed. In Rust, if you have a reference to some data, the compiler will ensure that the data will not go out of scope before the reference to the data does.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	let ref_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
	let s = String::from(&quot;hello&quot;);

	&amp;s
}
</code></pre></pre>
<p>Because <code>s</code> is created inside <code>dangle</code>, when the code of <code>dangle</code> is finished, <code>s</code> will be deallocated. But we tried to return a reference to it. That means this reference would be pointing to an invalid <code>String</code>.</p>
<h3 id="the-rules-of-references"><a class="header" href="#the-rules-of-references">The Rules of References</a></h3>
<ul>
<li>At any given time, you can have <em>either</em> one mutable reference <em>or</em> any number of immutable references.</li>
<li>References must always be valid.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02-00-particularities.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="ch02-02-option-result.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02-00-particularities.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="ch02-02-option-result.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
